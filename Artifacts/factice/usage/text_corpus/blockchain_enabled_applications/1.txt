Introduction
Blockchain technology is poised to fundamentally change our online world. This is not some kind of  miraculous, cure-all, money-making solution. One specific use of blockchain such as Bitcoin, but rather the  fundamental shift for the offline world ushered in by the web with easy to use access to information and the  ability to make digital copies of data or content in an unprecedented ease for distribution across the globe.  Hence the name, the World Wide Web. That interconnectivity has suffered fundamental problems when it  comes to transactions - TRUST.
The fundamental shift that blockchain technology represents is a method for moving away from an  attempt to have a central trusted authority in a massively distributed network. But instead to have multiple  sources of trust that must all agree, based on an algorithm that this transaction can be trusted as valid.  Furthermore, most blockchain solutions offer an immutable and enduring record of a transaction as it  is hard for any trusted or untrusted source to change or modify. This presents a completely new level of  security, privacy, and TRUST to our online world. As you will see throughout this book, a variety of uses,  protocols, and standards make up the current blockchain ecosystem.
We also strive to strike the perfect balance between being a technical reference and a how-to handbook  that shows practical examples of both current and future state use cases. While not comprehensive, we do  select for several high promise areas where blockchain technology is beginning to enable applications for an  entirely new industry segment. We hope this book will inform you and provides a roadmap to your success  leveraging blockchain technology to enable new applications for your business.
Throughout the book, you will see many examples of applications to reinforce key points. Early  examples extend beyond financial transactions to cover other aspects of FinTech, RegTech (regulation),  InsuranceTech, GovTech (eVoting, licensing, records and certification), HealthTech, and many others.
In order to understand these early examples, it is necessary to explore the Blockchain history;  fundamentals of distributed trust; consensus; hardware, software and encryption in the early chapters.  Next, you’ll learn about the network transactions and simplified payments in Blockchain fundamentals.
We’ll compare this with the extended capabilities if Ethereum and specific characteristics like how gas  works and distributed apps along with examples of Blockchain as a Service. To further extend these  capabilities, two chapters are devoted to DAO/Decentralized Organizations and the details and examples in  these areas. In Chapter 7, Ethereum Tokens are highlighted for value creation with various technology and  business sector examples that highlight the power of Smart Contracts to allow multiple sources of value and  rules to be embedded in the transactions directly. The next three chapters- 8, 9 and 10 segment examples  into Blockchain in Science, Blockchain in Healthcare, and details on the structure of the Hyperledger  Project, respectively. The final two chapters, 11 and 12 explore many recent developments and future  trends, particularly in ICOs and the effect on financial markets and processes. Don’t miss the  late-breaking Appendix with a detailed interview with the Hashed Health leadership team and their insights  on Blockchain in Healthcare. We hope you find the information in this book useful as well as enjoyable  as you explore The fundamentals, current best practices and future potential of Blockchain Enabled  Applications. We welcome your feedback at info@metil.org.
xvii
CHAPTER 1
Behold the Dreamers
Why should a man intentionally live his life with one kind of anxiety followed by another? —Imbolo Mbue
Anxiety is perhaps the best way to describe the attitude that dominated the minds of investors and the  general public toward financial markets by the end of 2008. The 2008 financial crisis is considered by  numerous economists to have been the worst financial crisis since the Great Depression. The years leading  up to the crisis saw a flood of irresponsible mortgage lending and a massive systemic failure of financial  regulation and supervision. The fallout was so immense that it threatened the collapse of large financial  institutions. National governments had to intercede to bail out major banks. This chapter begins with a  discussion about the 2008 financial crisis, and then we discuss the aftermath, which led to an environment  where a new banking system and alternative currency such as Bitcoin could thrive. Then, we dive into  the technology stack that powers Bitcoin. Remarkably, the components of this stack are not entirely new,  but they are strung together in an ingenious design. Finally, we end the discussion by talking about the  heightened interest in blockchain, a major technical breakthrough that has the potential to revolutionize  several industries.
Paradigm Shift
Revolutions often look chaotic, but this one was brewing quietly, headed by an unknown individual under  the name Satoshi Nakamoto, who dreamed of changing the financial world. Any number of parties can  be blamed for the financial crisis, but the common denominator was that fundamental financial and  accounting instruments used to maintain integrity of the entire system became too complex to be used  efficiently. Trust, the ultimate adhesive of all financial systems, began to disappear in 2008. The regulations  have since changed to prevent similar circumstances from arising, but it was clear that there was a need for  autoregulation of trust between counterparties and transparency into their ability to enter any type of a sales  contract. A counterparty is essentially the other party in a financial transaction. In other words, it is the  buyer matched to a seller. In financial transactions, one of the many risks involved is called counterparty  risk, the risk that each party involved in a contract might not be able to fulfill its side of the agreement. The  systemic failure referenced earlier can now be understood in terms of counterparty risk: Both parties in the  transaction were accumulating massive counterparty risk, and in the end, both parties collapsed under the  terms of the contract. Imagine a similar transaction scenario involving multiple parties, and now imagine  that every single player in this scenario is a major bank or insurance company that further serves millions of  customers. This is just what happened during the 2008 crisis.
© Vikram Dhillon, David Metcalf, and Max Hooper 2017 1 V. Dhillon et al., Blockchain Enabled Applications, https://doi.org/10.1007/978-1-4842-3081-7_1
Chapter 1 ■ Behold the Dreamers
The next issue we need to discuss is that of double spending. We revisit this topic again strictly in the  context of Bitcoin, but let’s get a basic understanding of the concept by applying it to the financial crisis. The  principle behind double spending is that resources committed to one domain (e.g., one transaction) cannot  also be simulataneously committed to a second disparate domain. This concept has obvious implications for  digital currencies, but it can also summarize some of the problems during the 2008 crisis.
Here’s how it started: Loans (in the form of mortages) were given to borrowers with poor credit  histories who struggled to repay them. These high-risk mortgages were sold to financial experts at the big  banks, who packaged them into low-risk public stocks by putting large numbers of them together in pools.  This type of pooling would work when the risks associated with each loan (mortgage) are not correlated.  The experts at big banks hypothesized that property values in different cities across the country would  change independently and therefore pooling would not be risky. This proved to be a massive mistake. The  pooled mortage packages were then used to purchase a type of stock called collateralized debt obligations  (CDOs). The CDOs were divided into tiers and sold to investors. The tiers were ranked and rated by  financial standards agencies and investors bought the safest tiers based on those ratings. Once the U.S.  housing market turned, it set off a domino effect, destroying everything in the way. The CDOs turned out  to be worthless, despite the ratings. The pooled mortgages collapsed in value and all the packages being  sold instantly vaporized. Throughout this complex string of transactions, every sale increased the risk and  incurred double spending at multiple levels. Eventually, the system equilibrated, only to find massive gaps,  and collapsed under the weight. Following is a brief timeline for 2008. (This timeline was made following a  presentation by Micah Winkelspech at Distributed Health, 2016).
•  January 11: Bank of America buys the struggling Countrywide.
•  March 16: Fed forces the sale of Bear Stearns.
•  September 15: Lehman Brothers files for Chapter 11 bankruptcy.
•  September 16: Fed bails out American International Group (AIG) for $85 billion. •  September 25: Washington Mutual fails.
•  September 29: Financial markets crash; the Dow Jones Industrial Average fell 777.68  points and the whole system was on the brink of collapse.
•  October 3: U.S. government authorizes $700 billion for bank bailouts.
The bailout had massive economic consequences, but more important, it created the type of  environment that would allow for Bitcoin to flourish. In November 2008, a paper was posted on the  Cryptography and Cryptography Policy Mailing List titled “Bitcoin: A Peer-to-Peer Electronic Cash System,”  with a single author named Satoshi Nakamoto. This paper detailed the Bitcoin protocol and along with  it came the original code for early versions of Bitcoin. In some manner, this paper was a response to the  economic crash that had just happened, but it would be some time before this technological revolution  caught on. Some developers were concerned with this electronic cash system failing before it could ever take  hold and their concern was scalability, as pointed out in Figure 1-1.
2
Chapter 1 ■ Behold the Dreamers

Figure 1-1. Initial reception of the Bitcoin protocol included concerns about scalability and realistic prospects  for Bitcoin
So who is Nakamoto? What is his background? The short and simple answer is that we don’t know. In  fact, it is presumptuous to assume that he is actually a “he.” The name Satoshi Nakamoto was larely used as a  pseudonym and he could have been a she, or even a they. Several reporters and news outlets have dedicated  time and energy to digital forensics to narrow down candidates and find out the real identity of Nakamoto,  but all the efforts so far have been wild-goose chases. In this case, the community is starting to realize that  maybe it doesn’t matter who Nakamoto is, because the nature of open source almost makes it irrelavent.  Jeff Garzik, one of the most respected developers in the Bitcoin community, described it as follows: “Satoshi  published an open source system for the purpose that you didn’t have to know who he was, and trust who he  was, or care about his knowledge.” The true spirit of open source makes it so that the code speaks for itself,  without any intervention from the creator or programmer.
Cypherpunk Community
Nakamoto’s real genius in creating the Bitcoin protocol was solving the Byzantine generals’ problem.  The solution was generalized with components and ideas borrowed from the cypherpunk community.  We briefly talk about three of those ideas and the components they provided for the complete Bitcoin protocol:  Hashcash for proof of work, Byzantine fault tolerance for the decentralized network, and blockchain to remove  the need for centralized trust or a central authority. Let’s dive into each one, starting with Hashcash.
Hashcash was devised by Adam Black in the late 1990s to limit e-mail spam with the first of its kind  Proof-of-Work (PoW) algorithm. The rationale behind Hashcash was to attach some computational cost to  sending e-mails. Spammers have a business model that relies on sending large numbers of e-mails with very  little cost associated with each message. However, if there is even a small cost for each spam e-mail sent, that  cost multiplies over thousands of e-mails, making their business unprofitable. Hashcash relies on the idea of  cryptographic hash functions: A type of hash function (in the case of Bitcoin, SHA1) takes an input and converts  it into a string that generates a message digest, as shown in Figure 1-2. The hash functions are designed to have  a property called one-way functions, which implies that a potential input can be verified very easily through the  hash function to match the digest, but reproducing the input from the digest is not feasible. The only possible  method of re-creating the input is by using brute force to find the appropriate input string. In practice, this is  the computationally intensive element of Hashcash and also eventually Bitcoin. This principle has become the  foundation behind PoW algorithms powering Bitcoin today and most cryptocurrencies. The PoW for Bitcoin is  more complex and involves new components, which we talk about at length in a later chapter.
3
Chapter 1 ■ Behold the Dreamers

Figure 1-2. Mechanism of a cryptographic hash function. It takes an input and consistently converts it to a  string of an output digest.
The next idea we need to discuss is the Byzantine generals’ problem. It is an agreement problem  among a group of generals, with each one commanding a portion of the Byzantine army, ready to attack  a city. These generals need to formulate a strategy for attacking the city and communicate it to each other  adequately. The key is that every general agrees on a common decision, because a tepid attack by a few  generals would be worse than a coordinated attack or a coordinated retreat. The crux of the problem is that  some of the generals are traitorous. They might cast a vote to deceive the other generals and ultimately lead  to a suboptimal strategy. Let’s take a look at an example: In a case of odd-numbered generals, say seven,  three support attacking and three support retreat. The seventh general might communicate an agreement  to the generals in favor of retreat, and an agreement to attack to the other generals, causing the whole  arrangement to fall apart. The attacking forces fail to capture the city because no intrinsic central authority  could verify the presence of trust among all seven generals.
In this scenario, Byzantine fault tolerance can be achieved if all the loyal generals can communicate  effectively to reach an undisputed agreement on their strategy. If so, the misleading (faulty) vote by the traitorous  general would be revealed and fail to perturb the system as a whole. For the Bitcoin protocol, Nakamoto’s  key innovation to enable Byzantine fault tolerance was to create a peer-to-peer network with a ledger that  could record and verify a majority approval, thereby revealing any false (traitorous) transactions. This ledger  provided a consistent means of communication and further allowed for removal of trust from the whole system.  The ledger is also known as the blockchain, and by attaching blockchain to Bitcoin, it became the first digital  currency to solve the double spending problem network-wide. In the remainder of this chapter, we present a  broad overview of the broad overview of the technology, and the concept of a blockchain-enabled application.
The blockchain is primarily a recording ledger that provides all involved parties with a secure and  synchronized record of transactions from start to finish. A blockchain can record hundreds of transactions  very rapidly, and has several cryptographic measures intrinsic to its design for data security, consistency,  and validation. Similar transactions on the blockchain are pooled together into a functional unit called a  block and then sealed with a timestamp (a cryptographic fingerprint) that links the current block to the  one preceding it. This creates an irreversible and tamper-evident string of blocks connected together by  timestamps, conveniently called a blockchain. The architecture of blockchain is such that every transaction  is very rapidly verified by all members of the network. Members also contain an up-to-date copy of the  blockchain locally, which allows for consensus to be reached within the decentralized network. Features  such as immutable record-keeping and network-wide consensus can be integrated into a stack to develop  new types of applications called decentralized apps (DApps). Let’s look at a prototype of a DApp in Figure 1-3,  in the context of the Model-View-Controller (MVC) framework.
■ Note The first block of the blockchain is called the Genesis block. This block is unique in that it does not  link to any blocks preceeding it. Nakmoto added a bit of historical information to this block as context for the  current financial environment in the United Kingdom: “The Times 03/Jan/2009 Chancellor on brink of second
bailout for banks. “This block not only proves that no bitcoins existed before January 3, 2009, but also gives a  little insight into the mind of the creators.
4
Chapter 1 ■ Behold the Dreamers

Figure 1-3. Simple prototype of a decentralized application that interacts with the end user at the final steps
The model and controller here rely on the blockchain for data (data integrity and security) and  accordingly update the view for the end user. The secret sauce in this prototype is the application  programming interface (API), which works to pull information from the blockchain and provides it to the  model and controller. This API provides opportunities to extend business logic and add it to the blockchain,  along with basic operations that take blocks as input and provide answers to binary questions. The  blockchain could eventually have more features, such as oracles that can verify external data and timestamp  it on the blockchain itself. Once a decentralized app starts dealing with large amounts of live data and  sophisticated business logic, we can classify it as a blockchain-enabled application.
Summary
In this chapter, we started talking about the history of Bitcoin and the financial environment at the time it  came into being. We continue our discussion of blockchain and specific features of the peer-to-peer network  such as miners and more in the upcoming chapters. The references used in this chapter are available at the  end of the book.
5
CHAPTER 2
The Gold Rush: Mining Bitcoin
During the Gold Rush, most would-be miners lost money, but people who sold them  picks, shovels, tents and blue-jeans (Levi Strauss) made a nice profit.
—Peter Lynch
Mining is a foundational concept in understanding how the Bitcoin protocol operates. It refers to a  decentralized review process performed on each block of the blockchain to reach consensus without the  need for a central authority to provide trust. In other words, mining is the computational equivalent of  peer review in a decentralized environment where neither party involved trusts the other. We continue  our discussion of a hash-function explained in Chapter 1 as it refers to mining and solving PoW functions.  Then, we integrate the concepts of block target values and network difficulty with mining and how mining  has evolved to keep up with the increasing difficulty. This will lead us further into talking about the types of  hardware mining that have recently been developed. We end the chapter with an analysis of startups that  began selling dedicated hardware for mining, leading to the Bitcoin mining arms race and their eventual  failure.
Reaching Consensus
Mining is central to the Bitcoin protocol and has two primary roles: adding new bitcoins to the money  supply and verifying transactions. In this chapter, we look at the mechanisms behind these two processes.  Essentially, mining is the appropriate solution to the double spending problem we discussed previously. To  remove the need for a central authority, individuals running the Bitcoin client on their own machines (called  miners) participate in the network and verify that transactions taking place between two parties are not  fraudulent. Mining is actually a computationally intensive activity, but what incentives does anyone have to  help mine for new Bitcoins? The key incentive for miners is getting a reward in the form of Bitcoins for their  participation. Let’s look at a simplified view of the mining process in Figure 2-1.
© Vikram Dhillon, David Metcalf, and Max Hooper 2017 7 V. Dhillon et al., Blockchain Enabled Applications, https://doi.org/10.1007/978-1-4842-3081-7_2
Chapter 2 ■ The Gold Rush: Mining Bitcoin

Figure 2-1. A simplified overview of the mining process
Unpackaged transactions that have recently occurred in the Bitcoin network remain in the transaction  pool until they are picked up by a miner to be packaged into a block. A miner selects transactions from the  transaction pool to package them in a block. After the block has been created, it needs a header before it  can be accepted by the blockchain. Think of this as shipping a package: Once the package has been created,  it needs to be stamped so that it can be shipped. A miner uses the header of the most recent block in the  blockchain to construct a new header for this current block. The block header also contains other elements  such as a timestamp, version of the Bitcoin client, and an ID corresponding to the previous block in the  chain. The resulting block is called a candidate block, and it can now be added to the blockchain if a few  other conditions are satisfied.
The process of mining is very involved and Figure 2-1 only serves to paint a broad picture regarding  the participation of miners in the protocol. Next, we explore the technical aspects of the stamp (analogy  referenced earlier) and the mechanism of stamping a package. Keep in mind that mining is a competitive  process: Figure 2-1 describes this process for only one miner, but in reality, a very large number of miners  participate in the network. The miners compete with each other to find a stamp for the package (block)  they created, and the first miner to discover the stamp wins. The race between miners to find a stamp is  concluded within ten minutes, and a new race begins in the next ten minutes. Once the stamp is discovered,  the miner can complete the block and announce it to the network, and then it can be added to the  blockchain. Let’s take a look at the process behind searching for the stamp, better known as a block-header,  in Figure 2-2.
8
Chapter 2 ■ The Gold Rush: Mining Bitcoin

Figure 2-2. Generating a block header by solving proof of work (PoW)
The package created by a miner is almost a block, but it is missing a header. It’s called a candidate  block and it can only be added to the blockchain after the stamp, or the header, is added. The header from  the most recent block in the blockchain is retrieved and combined with a 32-bit value called nonce. This  combination is directed to the hash function (SHA-256) as an input. The hash function computes a new  resulting hash as an output. This generated hash is then compared to the target value of the network (at the  given time). If the hash value is larger than the target value, then the nonce is readjusted and a new input  is sent to the hash function to obtain a new potential output. The problem of finding the appropriate hash  value that is smaller than the target value is at the heart of PoW, and it can only be solved using brute force.  Once a hash value smaller than the target value is discovered by a miner, this hash can then be used in the  block header for the candidate block. The first miner to discover the hash is considered to be the winner. The  winning miner has shown PoW that she did to discover the hash, so the transactions contained within the  block are now considered valid. This block can now be added to the blockchain. Additionally, the winning  miner also earns the reward for solving the PoW problem, which is a certain number of Bitcoins. This whole  process from packaging transactions into a block, to finding the hash and announcing the block to the  Bitcoin network repeats itself approximately every ten minutes.
9
Chapter 2 ■ The Gold Rush: Mining Bitcoin
We introduced some new terminology in Figure 2-2, so let’s describe the terms here properly for the  sake of completion.
•  Candidate block: An incomplete block, created as a temporary construct by a miner  to store transactions from the transaction pool. It becomes a complete block after the  header is completed by solving the PoW problem.
•  PoW: The problem of discovering a new hash that can be used in the block header  of the candidate block. This is a computationally intensive process that involves
evaluating a hash taken from the most recent block and appending a nonce to it
against the target value of the network. This problem can only be solved using brute  force; that is, multiple trials of using the hash (from the most recent block header)  and nonce being adjusted each time are necessary to solve the PoW problem.
•  Nonce: A 32-bit value that is concatenated to the hash from the most recent block  header. This value is continuously updated and adjusted for each trial, until a new  hash below the target value is discovered.
•  Hash function: A function used to compute a hash. In the Bitcoin protocol, this  function is the SHA-256.
•  Hash value: The resulting hash output from a hash function.
•  Target value: A 265-bit number that all Bitcoin clients share. It is determined by the  difficulty, which is discussed shortly.
•  Coinbase transaction: The first transaction that is packaged into a block. This is a  reward for the miner to mine the PoW solution for the candidate block.
•  Block header: The header of a block, which contains many features such as a
timestamp, PoW, and more. We describe the block header in more detail in Chapter 3.
■ Note After going over the terms defined above, revisit Figures 2-1 and 2-2. Some concepts that were  abstract will become clear now and the information will integrate better.
Now that we have a better idea of how mining works, let’s take a look at mining difficulty and target  values. Those two concepts are analogous to dials or knobs that can be adjusted over the course of time  for the network and all Bitcoin clients update to follow the latest values. So what is mining difficulty?  Essentially, it can be defined as the difficulty of finding a hash below the target value as a miner is solving  the PoW problem. An increase in difficulty corresponds to longer time needed to discover the hash and  solve PoW, also known as mining time. The ideal mining time is set by the network to be approximately ten  minutes, which implies that a new block is announced on the network every ten minutes. The mining time  is dependent on three factors: the target value, the number of miners in the network, and mining difficulty.  Let’s look at how these factors are interconnected.
1. An increase in mining difficulty causes a decrease in the target value to
compensate for the mining time.
2. An increase in the number of miners joining the network causes an increase in  the rate at which PoW is solved, decreasing the mining time. To adjust for this,
mining difficulty increases and the block creation rate returns to normal.
3. The target value is recalculated and adjusted every 2,016 blocks created, which  happens in approximately two weeks.
10
Chapter 2 ■ The Gold Rush: Mining Bitcoin
As we can see, there is a common theme of self-correction in the Bitcoin network that allows it to  be very resilient. Miners are the heartbeat of the Bitcoin network and they have two main incentives for  participation:
•  The first transaction to be packaged in a block is called the coinbase transaction.  This transaction is the reward that the winning miner receives after mining the block  and announcing it on the network.
•  The second reward comes in the form a fee charged to the users of the network for  sending transactions. The fee is given to the miners for including the transactions in  a block. This fee can also be considered a miner’s income because as more and more  Bitcoins are mined, this fee will become a significant portion of the income.
Now we can put these concepts together in the form of another flowchart, as shown in Figure 2-3. This  will help solidify the process of mining in the context of difficulty and target values.
Figure 2-3. Solving the PoW problem
Miners across the network compete to solve the problem and the winning miner announces the block  to the network, which then gets incorporated in the blockchain. To solve the PoW, a miner has to keep  generating new hash values (through the hash function) using the incremented nonce until a hash that is  below the target value is discovered. In this case, notice that the nonce is the only adjustable value. This is a  simplified PoW scheme and there are small differences in its implementation.
■ Note The term mining is used because the process is similar to the mining of rare metals. It is very  resource intensive and it makes new currency avaliable at a slow rate, just like the miners in the Bitcoin  protocol getting rewarded.
11
Chapter 2 ■ The Gold Rush: Mining Bitcoin
We talked about the self-correction properties in Bitcoin network and how they allow the network to  adapt. Next, we take a look at an unexpected case of having a very large number of miners in the network  as Bitcoin gained popularity. This led to an arms race of sorts and it had far-reaching consequences. First,  though, we need to talk about the new types of mining hardware that emerged.
Mining Hardware
As Bitcoin started to gain more popularity and acceptance with merchants, more miners joined the network  in hopes of earning rewards. Miners began to get more creative with how they approached mining, such  as using specialized hardware that can generate more hashes. In this section, we discuss the evolution of  mining hardware as Bitcoin started to spread globally.
•  CPU mining: This was the earliest form of mining available through the Bitcoin  clients. It became the norm for mining in the early versions of the Bitcoin client, but  was removed in the later updates because better options became accessible.
•  GPU mining: This represented the next wave of mining advancements. It turns out  that mining with a graphics processing unit (GPU) is far more powerful because it  can generate hundreds of times more hashes than a central processing unit (CPU).  This is now the standard for mining in most cryptocurrencies.
•  FPGAs and ASICs: Field-programmable gated arrays (FPGAs) are integrated
circuits designed for a specific use case. In this case, the FPGAs were designed
for mining Bitcoins. The FPGAs are written with very specific hardware language
that allows them to perform one task very efficiently in terms of power usage and  output efficiency. Shortly after the introduction of FPGAs, a more optimized, mass produceable, and commercial design came out in the form of application-specific  integrated circuits (ASICs). The ASICs have a lower per-unit cost, so the units can be  mass produced. The ASICs-based devices are also compact, so more of them can be  integrated in a single device. The ability of ASICs to be combined in arrays at a low  price point made a very convincing case for accelerating the rate of mining.
•  Mining pools: As the mining difficulty increased due to the rise of ASICs, miners  realized that individually, it was not financially wise to continue mining. It was
taking too long, and the reward did not justify the resources that went into mining.  The miners then organized themselves into groups called pools to combine the
computational resources of all the members and mine as one unit. Today, joining a  pool is very common to get started with mining in almost every cryptocurrency.
•  Mining cloud services: These are simply contractors who have specialized mining  rigs. They rent their services to a miner according to a contract for a given price to  mine for a specific time.
It is easy to see how ASICs completely changed the mining game after developers and hardware  hobbiysts realized that custom arrays of ASICs can be assembled at a fairly cheap price point. It was the  beginning of a kind of arms race in Bitcoin hardware, as developers were designing new chips and buying  new equpiment for mining rigs that allow them to mine the most Bitcoin. This initial push, driven by  profit, accelerated Bitcoin’s reach and created a golden era for the alternative currency. More developers  and enthusiasts joined in, buying custom hardware to maximize their profits. The network responded by  increasing the difficulty as the number of miners increased. Within a short time span, the bubble could not  sustain itself for the miners due to the self-correcting features present in the protocol and the difficulty kept  rising. In some cases, the hardware that miners purchased could no longer mine profitably by the time it  arrived from the factory. A significant capital investment was required up front to achieve any appreciable
12
Chapter 2 ■ The Gold Rush: Mining Bitcoin
returns. Most of the ASICs hardware is now historic, and even Bitcoin mining pools are not profitable for  the average miner. The startups and companies that commercialized ASICs and custom hardware made a  decent short-term profit and then flopped. We examine a few of those massive failures in the next section.
Startup Stories
In this section, we highlight a few stories from the gold rush era of Bitcoin between mid-2013 and late 2014.  The startups covered here followed the strategy of selling pickaxes to make profits, but some took it a step  further. The first startup we discuss is Butterfly Labs. This company out of Missouri came about in late 2011  with the promise of selling technology that was capable of mining Bitcoin leaps and bounds ahead of the  competition. Their ASICs were supposedly able to mine Bitcoin 1,000 times faster, and they opened up for  preorders soon after the initial announcement in 2012. Miners flocked to purchase the hardware, which  was promised for delivery by December of the same year. Butterfly Labs collected somewhere between $20  million and $30 million in preorders as reported by the Federal Trade Commission (FTC). Shipments started  to roll out to only a few customers around April 2013, but most customers did not receive their mining  equipment for another year. When the customers did recieve their machines, they were obsolete, and some  accused Butterfly Labs of using the hardware to mine for themselves before delivering them. Despite being  unable to follow through with their initial orders, Butterfly Labs began offering a new and much more  powerful miner and opened preorders for that new miner. Ultimately, the company became one of the most  hated in the Bitcoin community, and the FTC had to step in to shut it down.
The second company we discuss, CoinTerra, is a more complicated case because the startup was  founded by a team that had deep expertise in the field. The CEO, Ravi, was a CPU architect at Samsung  previously, and the company’s board included many other leaders in the field. Initially, they were venture  backed and well funded, and in 2013, they announced their first product, TerraMiner IV, which was  supposed to be shipped in December of the same year. The company could not ship the product in time and  eventually pushed the date back. The miner still did not arrive in 2014 and eventually CoinTerra apologized  to customers, offering them some compensation, which was also largely delayed, frustrating customers even  further. It seems that the company is trying to pivot to cloud mining services, but most of its customer base  has already lost their trust.
The final case focuses on a startup called HashFast. Similar to previous two examples, HashFast  was offering miners called Baby Jet that would be delivered in December 2013. The team at HashFast  overpromised the features and underdelivered at a time when difficulty skyrocketed. It is likely that the  company took the cash from early adopters to fund its own development, and when they encountered  difficulties, the customers demanded refunds for their orders. The problem at the time was that the price  of Bitcoin increased steadily, so the company did not have enough funds to pay back the customers. They  were facing multiple lawsuits and running out of cash reserves very fast. Eventually, a judge allowed the  auctioning of all assets that the company owned to pay back the creditors and investors. A common theme  these companies share is that they were frequently unable to deliver mining hardware on the promised  timeline and significantly delayed or refused to issue any refunds to their customers.
We can construct a general scheme of operations from the cases presented here and other ASICs  startups that failed similarly to Butterfly Labs:
•  Open for preorders at very high prices and falsely advertise a ridiculously high  hashing rate with a huge return on investment.
•  Invest all the funding from preorders to begin research and development for ASICs  and custom hardware.
•  Once the mining hardware has been obtained from overseas manufacturers, use it to  mine nonstop for months internally.
13
Chapter 2 ■ The Gold Rush: Mining Bitcoin
•  Broadcast to customers through social media that the manufacturing process is  taking longer than expected.
•  Deliver the hardware only to the customers that threaten to sue as early proof that  shipments have begun rolling out.
•  Deliver the ASICs hardware to other customers when it is already severely
out of date.
•  Customers complain and file lawsuits, and the company eventually falls apart and  faces huge fines.
New Consensus
We conclude this chapter by talking about the same theme that we started it with: consensus. This chapter’s  central idea was that in Bitcoin, mining is used to reach consensus to prevent users from double spending  and validate all the transactions. However, since the advent of Bitcoin, other consensus algorithms have  been developed. We refer to the PoW algorithm referenced in the original Bitcoin protocol for reaching  consensus as the Nakamoto Consensus. A new consensus algorithm that has recently become popular is  known as proof of stake (PoS), where the participants essentially play the role of validators. In Bitcoin, bad  actors with fraudulent transactions have to face a rigorous approval process and validation from the network  of miners. In PoS, the participants have a stake in the network (hence the name) in the form of currency.  As such, they want to see the network succeed and trust emerges in blocks that have the largest stake of  currency invested by the validators. Additionally, the malicious validators will get their stake slashed for  acting in bad faith. We dive into the technical aspects of PoS, and how it compares to the mechanism of  PoW, later in the book. Our journey ends in this chapter with consensus and we pick up our discussion on  the Bitcoin network and the blockchain in the next chapter.
Summary
In this chapter, we talked about the concept of mining and presented the technical background necessary to  understand how miners verify blocks. We discussed in depth the backbone of mining in Bitcoin called PoW,  and throughout the remainder of the book, we present other consensus mechanisms. Then, we described  the arms race in Bitcoin mining over producing the best hardware, which led to the huge rise in difficulty,  and the startup failures that resulted from that time period. Finally, we ended the chapter with a mention of  PoS, which we return to in a later chapter.
References
The key references used in preparing this chapter were Michael Nielsen’s post (http://www. michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/) on Bitcoin mining, and Aleksandr  Bulkin’s post (https://keepingstock.net/explaining-blockchain-how-proof-of-work-enables trustless-consensus-2abed27f0845). The remaining references can be found at the end of  the book.
14
CHAPTER 3
Foundations of Blockchain
You never change things by fighting the existing reality.
To change something, build a new model that makes the existing model obsolete. —R. Buckminster Fuller
The blockchain is a decentralized data structure with internal consistency maintained through consensus  reached by all the users on the current state of the network. It’s an enabling technology that resolved the  Byzantine generals’ problem (message communication between untrusted parties) and opened up a new  horizon of possibilities for trustless transactions and exchange of information. If the Internet democratized  the peer-to-peer exchange of information, then the blockchain has democratized the peer-to-peer exchange  of value. We begin this chapter by exploring how transactions work between users on the Bitcoin network.  This entails a technical discussion of structures of a block and a transaction. We then dive into the role of  wallets and user addresses. After talking about wallets, we shift our focus to Simple Payment Verification  (SPV) implemented in the Bitcoin network. SPV allows us to understand why blocks have a peculiar  structure and more important, how the Bitcoin network can retain efficiency despite the network scaling at  a high rate. Finally, we conclude our discussion by talking about hard and soft forks in the blockchain. We  present the implications of forks in the context of forward compatibility for merchants and users involved in  running the Bitcoin-core code.
Transaction Workflow
The central purpose of the Bitcoin protocol is to allow transactions to occur over the network between  users in a decentralized manner. We have been talking about small fragments of the protocol to build up  background. Now we can integrate those concepts into a single framework and explore the blockchain. The  ultimate result of mining is increasing the number of blocks as the network evolves over time. To understand  how transactions occur between two users (Alice and Bob), we first need to understand the structure of  blocks that hold the transactions. In the simplest terms, the blockchain is a collection of blocks bound by two  main principles:
•  Internal consistency: There are a few design principles inherent to the functioning of  each block that make the blocks internally consistent. For instance, each block links  to the previous one in the chain and has a creation timestamp. Such mechanisms
in the blockchain allow it to be an internally coherent data structure that can keep a  consistent record of transactions.
© Vikram Dhillon, David Metcalf, and Max Hooper 2017 15 V. Dhillon et al., Blockchain Enabled Applications, https://doi.org/10.1007/978-1-4842-3081-7_3
Chapter 3 ■ Foundations of Blockchain
•  Consensus on transactions: The concept of mining described in Chapter 2 is just one  implementation for verifying transactions; there are different methods where no
brute-force hashing is involved. However, in every one of these implementations,
there is a scheme of reaching consensus on the transactions that have transpired
during some interval in the network. We can generalize this verification of
transactions for a decentralized system by either using some sort of PoW or a similar  strategy that pools transactions that are then checked by users on the network.
A transaction is essentially a data structure carried on a block, but how exactly? To discover the process,  let’s look at the complete structure of a block in Figure 3-1. Each block has at least two unique components:  the block header, which contains a unique hash (called the merkle root) that uniquely identifies a block,  and the transaction list, which contains new transactions. Note that each block contains the same amount  of transactions in the list, but the precise transactions between users are different. This is because only one  block wins the mining race every ten minutes on the blockchain, other candidates are rejected, and the race  starts again. In this simplified model, there are only two other components of a block: the block size, which  is kept consistent for the entire network, and a counter for the number of transactions in each block. Here,  we focus more on the block header and the transaction list.
The block header contains a few standard components, such the as difficulty target and the nonce  discussed previously. It also contains the version number of the Bitcoin core-code that the winning miner is  running. The timestamp is also a unique feature of every block, as it unmistakably identifies one particular  block in the network. The header also contains a hash from the previous block in the chain, and a special  hash that identifies this block called the merkle root. We discuss how this special hash comes to be later in  this chapter.
■ Proof of life Recently, there were rumors that Julian Assange, the WikiLeaks founder, had died. Assange  recently did an Ask Me Anything session on Reddit and responded to the rumors by reading the most recent  block hash from the blockchain to prove that he was indeed alive. The block was created only ten minutes  earlier, so this could not have been a prerecording, thus proving beyond any shadow of a doubt that Assange  was alive. This was the first time the block hash found a use in a sense of popular culture, and Assange called it  a proof of life.
16
Chapter 3 ■ Foundations of Blockchain

Figure 3-1. Simplified overview of the structure of a block
The block header and transaction list are the two components that stay unique to every block. The  block header is made up of several smaller parts, the most peculiar of which is the merkle root, a hash that  uniquely identifies a block. The header contains the hash of the previous block, the nonce used to create that  particular block, and the difficulty of the network. These are standard mining components that we discussed  previously. Each block also contains a list of transactions. Aside from the actual transactions, the transaction  list also contains a few components that are crucial to how a block will accept the transaction. For instance,  the lock time delay dictates when a transaction can be accepted into a block. Finally, the list contains all  the transactions accepted into this block as a series of signed inputs and outputs that ensure the transfer of  Bitcoins from the sender to the receiver.
There are several new terms and concepts introduced here and we will go through all of them now.  We already talked about the block header and the concepts of timestamp on a block, the merkle root, and a  hash from the previous block. Now we focus on the components of the transaction list. Let’s begin with the  delay. The proper technical term is lock time delay, which refers to the time after which a transaction can  be accepted into a block. The precise mechanism involves the use of a parameter called blockheight, which  increases as more blocks are added to the blockchain. A given transaction remains locked and unverified  until the blockheight specified for that transaction is exceeded.
17
Chapter 3 ■ Foundations of Blockchain
Next is the concept of transaction inputs and outputs. The foundational unit of a transaction is called  an unspent transaction output (UTXO), which can have a value given in Satoshis. Similar to how a dollar can  be split into 100 cents, Bitcoin can be divided into an eight-decimal unit called Satoshis. A UTXO is a unit of  currency controlled by users (the users are also known as owners) and recorded on the blockchain. More  precisely, UTXO is really the currency balance, or the unspent currency present in the Bitcoin economy.  The entire network accepts UTXO as currency and whenever a user receives Bitcoin, the amount is recorded  on the blockchain as a UTXO. Essentially, the Bitcoin belonging to a user can be spread across several  transactions and many blocks as UTXO. As a result, there is no defined concept of stored balance for a  particular user, but only UTXOs spread across the network possessed by the owners. The idea of an account  balance is actually created for a user by the wallet software, which searches the blockchain and collects all  the UTXO belonging to a particular address. We discuss the concepts of wallets and addresses shortly.
To understand UTXO properly, we need to talk about the concept of change. The idea is very simple,  actually. Think about the last time you bought groceries and paid with cash. You probably got some change  back that was left over from your payment. UTXOs have a similar concept, as shown in Figure 3-2. Every  transaction is split into a portion that is spent and locked (assigned) to another user, and a portion that gets  returned back to the original user, just like the change that you would get from shopping. In a transaction,  UTXOs that are consumed by the transaction are called the inputs, and the UTXOs created by a transaction  are called the outputs. The example in Figure 3-2 illustrates a similar scenario, where Bob wants to send one  BTC to Alice, but in the process, the ten BTC owned by Bob are split into two parts: the one BTC sent to Alice,  which is now assigned to her, and the nine BTC that are returned to Bob in the form of UTXOs. Both of these  components are recorded on the blockchain because they are a part of a transaction, as shown in Figure 3-2.
Figure 3-2. Format of a UTXO in the transaction list
In this example, Bob wants to send one BTC to Alice, and Figure 3-2 shows how this transaction occurs.  The BTC owned by Bob is used as the input of the transaction and the output is two parts, one sent to Alice  for one BTC and the second one returned as change back to Bob. It should be noted here that the initial  transaction, the newly assigned transaction, and the change are recorded on the blockchain as the input and  output.
Now that we have a better grasp of UTXOs, let’s talk about how transactions are assigned from one  user to another. This involves the use of private–public key pairs that lock and unlock the transactions. The  process works as follows:
•  A user, Alice, initiates a transaction that she wants to send to Bob.
•  Alice uses her private key to sign the transaction.
•  The transaction is broadcast on the network and anyone can use Alice's public key to  verify that the transaction originated from her.
18
Chapter 3 ■ Foundations of Blockchain
•  Bob receives the transaction after it has been verified on the network and propagated  to him.
•  Bob unlocks the transaction using his private key. The transaction was signed with  a script such that only the recipient could unlock the transaction and assign it to
themselves.
We mention that the transaction locking and unlocking mechanisms use a script, so what is this  script? The Bitcoin protocol uses a minimal, bare-bones, Turing-incomplete programming language to  manage transactions. Satoshi’s intention was to keep the programming logic very simple and largely off  the blockchain whenever possible. A script is attached to every transaction and it contains instructions on  how the user receiving Bitcoins can access them. Essentially, the sender needs to provide a public key that  anyone on the network can use to determine that the transaction did indeed originate from the address  contained in the script, and a signature to show that the transaction was signed by using the sender’s private  key. Without the private–public key pair authorization, transactions between users would not occur. Let’s  complete the picture that we started to create with the UTXOs, shown in Figure 3-3.
Figure 3-3. Transactions on the blockchain
Conceptually, it might be bizarre to consider transactions on the network as UTXOs being spread across  hundreds of blocks, but this process is exactly how transactions are propagated across the network. In this  example, Bob first initiated the transaction that was sent to Alice in which one BTC was assigned to Alice.  He received nine BTC in change as the unspent output. Alice further sends 0.5 BTC to another user and in  doing so, she receives 0.5 back in change from her transaction. Notice that the first transaction was signed  by Bob, who initiated the transaction, and then Alice signed the second transaction. In a sense, the output  from the first transaction became an input for the second, so Bob’s signature was retained as proof of the  first transaction and Alice’s signature now serves as the unlocking mechanism. This is how transactions can  be tracked across the Bitcoin network from the origin to the final owner (final address). By using network  addresses, the network retains a level of pseudonymity.
Now that we have talked about UTXOs, signatures, scripts, and how transactions are recorded, let’s  integrate these concepts and review the workflow of a transaction between Alice and Bob, shown in Figure 3-4.
19
Chapter 3 ■ Foundations of Blockchain

Figure 3-4. Overview of a transaction on the network
Alice initiates the transaction from her wallet, which contains multiple addresses. Each address  has a certain amount of Bitcoin balance (the sum of all UTXOs associated with that address) that can be  used to create new transactions. The transaction is then signed using Alice’s private key and it enters the
mining phase, where it will be packaged into a candidate block. As the mining concludes, the winning  miner announces the block on the network and the block is included into the blockchain. The remaining  transactions are thrown into the pool of transactions to be added. The transaction propagates to Bob, who  can now use his private key to unlock the transaction output amount and use it. The ideas of UTXOs, signing,  and script locking and unlocking provide deeper insights into how the blockchain remains internally  consistent as a decentralized ledger.
20
Chapter 3 ■ Foundations of Blockchain
Figure 3-4 introduces the concept of the wallet, which can be used to initiate transactions. Wallets are  now a standard part of the Bitcoin core-code and they mainly serve three purposes for the users:
•  Create transactions: A user can create transactions easily with a graphical interface  using the wallet.
•  Maintain balance: The wallet software tracks all the UTXOs associated with an  address and gives a user his or her final balance.
•  Maintain multiple addresses: Within the wallet, a user can have multiple addresses  and each address can be associated with certain transactions.
In a sense, addresses are the only means of ownership in the Bitcoin network. UTXOs and balances are  associated with a particular address and a user can create as many addresses as her or she wants. We saw in  Figure 3-4 that Alice had three addresses in her wallet, and each of the addresses can work with her private  key. There are actually other types of wallets, aside from a software wallet. Figure 3-4 used a software wallet,  but the process is similar for the other two main types, mobile wallets and a cold storage physical wallet.
Mobile wallets have largely been designed for the sake of convenience and as a gateway into the world  of mobile payments using cryptocurrencies such as Bitcoin. These wallets often serve as an independent but  miniaturized version of a complete wallet, and allow for access to balances and transactions on the go. The  apps that work as wallets are often designed in an open source environment, so they are also helping bring  developers and power users together in the community. Cold storage wallets are a more permanent method  of storing Bitcoins over a long period of time. There have been instances where wallets got corrupted  or the users couldn’t remember the key to unlocking those wallets, rendering their balance effectively  useless. There is no recovery mechanism for a password on a wallet. The idea here is to create a new wallet,  and send a transaction to a new address on that wallet. Now this wallet can be backed up and saved to a  physical device such as a flash drive and stored away securely. Once that transaction has been verified on  the blockchain, your Bitcoins are safe to be retrieved from the flash drive at any time. This can be done to  prevent any accidents from happening and to keep your currency separate from the main wallet that you use  to conduct transactions or mine for Bitcoins. Some developers have taken a step further and created paper  wallets where the address is encoded in a QR code and a private key for that particular wallet is also printed  on the paper in another QR code.
■ Note How can you actually see your transaction taking place on the Bitcoin network without having  to write a script or code yourself to do it? In Bitcoin (and most cryptocurrencies), there is a feature called  Blockchain Explorer, usually a web site where all transactions are visible from the Bitcoin network. You can  obtain all sorts of details about transactions, such as the origin of the transaction, the amount, the block hash,  or how many verifications it received.
Simple Payment Verification
So far, we have talked about the structure of blocks, transaction lists, how transactions occur between  users, and how they are recorded on the blockchain. Blocks are fundamentally data structures linked on  the blockchain, and transactions can be thought of as property of that data structure. More precisely, in  the case of blockchains, transactions are represented as leaves of a merkle tree. Hashes have been used  throughout the Bitcoin protocol as a method for maintaining data consistency because a hash is very easy to  verify and nearly impossible to reverse engineer. Building on these properties, we can tackle a very difficult  technical challenge on the blockchain: How can we check if a particular transaction belongs to a block?
21
Chapter 3 ■ Foundations of Blockchain
Checking through an N number of items in a list would be very inefficient, so we cannot simply check every  transaction in a blockchain containing millions of blocks to verify. This is where a merkle tree provides  speed and efficiency.
To visualize a merkle tree, refer to Figure 3-5. It is constructed from the transactions of a block to allow  fast access for verification purposes. Let’s follow the example shown in Figure 3-5. In this case, there are  eight transactions collected in a block and represented on a merkle tree. The lowest level is the transactions  themselves, and they are abstracted to a higher level by hashing two transactions together and obtaining  an output hash. This hash is combined with a second one and hashed again to abstract a higher level. This  process is repeated until only two hashes are left. Notice that each level contains information about the level  below, and finally the highest level holds a hash with information from the entire tree. This hash is called the  merkle root. How would a merkle root assist in finding a transaction? Let’s run through the example shown  in Figure 3-6 and try to find transaction 6 from the merkle tree. For starters, the merkle root allows us to skip  the other half of the tree, and now our search is limited to transactions 5 through 8. The hashes guide the  search further, allowing us to step into (reach) transaction 6 in just three steps. Compare this to searching  through the whole tree, stepping into every level, and comparing every transaction to see if it is indeed  transaction 6. That process would be more involved in terms of the steps taken and the time needed, and  this becomes too exhausting if the search expands to millions of transactions.
Figure 3-5. Constructing a merkle root
The lowest level is formed from the transactions and the general idea is to keep hashing two elements  together and retain some information about the level below. Ultimately, we are left with only two elements  that are hashed together to form the merkle root.
When would searching for a transaction come in handy? Every new user to get started with the standard  Bitcoin wallet client has to download the entire blockchain. Over time, the blockchain has increased in  download size, recently reaching a few gigabytes. This can be intimidating to new users, who cannot use  their wallets until the blockchain download is finished, and it might turn them away. To solve the problem  of having to download a bloated blockchain with historic transactions, Satoshi came up with a solution  called SPV. The rationale in SPV is to create a wallet client that downloads only the block headers instead of  the entire blockchain. This new lightweight client can use the merkle root in the block headers to verify if a  particular transaction resides in a given block. The precise mechanism requires the wallet to rely on a merkle
22
Chapter 3 ■ Foundations of Blockchain
branch and reach the specific transaction, much like the example shown in Figure 3-6. Currently, for Bitcoin,  there is an alternative wallet client known as Electrum that implements SPV and allows new users to avoid  the hassle of downloading the entire blockchain.
Figure 3-6. Finding a transaction using the merkle root
The root allows us to skip half of the tree during our search and the next level narrows down the search  even further. Using the merkle root, we can reach the transaction in just three steps, which allows a very high  operational efficiency that we would need in Bitcoin’s current network. The path to reaching transaction 6 is  also known as a merkle branch, connecting the root to a leaf.
Blockchain Forks
Here’s an interesting scenario to consider: Several miners are competing to solve the PoW and create a  block. Incidentally, two miners find a valid value within a few seconds of each other and broadcast them  to the network. What happens now? This situation is known as a fork, and it is completely normal on the  Bitcoin network, especially as the network starts to scale and include thousands of miners. To resolve the  fork, there are a few rules in place on the network, called the consensus rules. The tie creates two versions of  the blockchain, and this tie is resolved when the next block is discovered. Some of the peers will be working  on one version of the blockchain, and others will be working on the second version. When the next block  is discovered, one of the chains will become longer due to the inclusion of this new block. This chain now  becomes the active chain and the nodes will converge to the new chain. This process is visually illustrated in  Figure 3-7.
23
Chapter 3 ■ Foundations of Blockchain

Figure 3-7. Fork in the chain
In this example, block 4 is discovered at the same time by two miners, but the tie is resolved when the  next block is discovered on Branch B. This branch now becomes the active chain and all the nodes converge  to using Branch B as the new active chain.
Normal forks on the blockchain are not a concerning event, because they are usually resolved within a  matter of minutes. Soft and hard forks are an entirely different matter, however. These can occur in the case  of upgrades to the Bitcoin core-code where a permanent split happens between nonupgraded nodes that  cannot validate any newly created blocks and upgraded nodes that have begun creating blocks following the  new consensus rules. Two entirely different types of blocks begin to appear on the network and the network  is unable to converge on a single active chain until the nodes are upgraded to the new rules.
In this case, there are two possible outcomes. The first possibility is that the majority of the network  switches over to the new rules (a soft fork), and the new rules allow for the carryover of some portion of the  valid old blocks. The second alternative is that the old blocks remain invalid for the new nodes, and no old  blocks are accepted in the network by the new nodes. This is a hard fork, where no forward compatibility  exists and the old blocks will no longer be accepted by the new nodes. All the miners and nodes have to  upgrade to the new software so that their blocks can be considered valid under the new rules. A hard fork can  be chaotic and cause a problem for users and merchants that have created payment terminals and interfaces  relying on the old rules for transactions. They have to upgrade their back-end software to be compatible  with the new rules and ensure a smooth transition of incoming Bitcoins. A hard fork is not upcoming for the  Bitcoin network, but developers have begun researching just how complex the process might be. We end  our discussion of the blockchain forks here, but we return to it later. In the next chapters, we take a look at  circumstances in which a hard fork might become necessary in the next generation of Bitcoin protocols.
Summary
In this chapter, we integrated the concepts of mining into the whole blockchain network. We described  what a blockchain is and how it functions at a technical level. Then, we described the workflow of a  transaction and tracking unspent transaction outputs. We talked about how transactions are put together  and propagated on the blockchain and also mining software such as a wallet and mining client. Then, we  put mining in the context of a proper network and showed how a transaction goes from being included in  a block to being propagated. After that, we talked about the concept of SPV and the importance of merkle  hashes and roots in Bitcoin. We ended the chapter with a discussion of blockchain forks and how they  influence the network, which we revisit later in the book as well.
References
The main references used to prepare this chapter are the Bitcoin Developer Guide for discussions on UTXOs  and block headers. Georg Becker’s work on Merkel Tree signatures was used to prepare the sections on  Simple Payment Verification and Merkel roots.
24
CHAPTER 4
Unpacking Ethereum
Any sufficiently advanced technology is indistinguishable from magic.
—R. Buckminster Fuller
Ethereum is an open source, decentralized, blockchain platform with computational capabilities that  reconstruct elementary currency exchange into a transfer of value between users via a scripting language.  Ethereum is widely recognized as a successor to the Bitcoin protocol, generalizing the original ideas and  enabling a more diverse array of applications to be built on top of blockchain technology. Ethereum has two  essential components. The first is a Turing-complete virtual processor that can load resources and execute  scripts, called the Ethereum Virtual Machine (EVM). The second component is a token of value called Ether,  which is the currency of the network used for user-to-user transactions or compensation to miners of the  network. In this chapter, we begin our journey with an overview of Ethereum’s architecture in comparison  to Bitcion, focusing on the EVM and Turing-completeness properties. Following the architecture, there is  a short discussion on the accounts model in Ethereum, and account representation with Merkel-Patricia  Trees. This will lead us to global state in Ethereum, account storage and gas, which is a spam-prevention  mechanism in the network. Then, we deconstruct the notion of a smart contract enabled by EVM, the  security concerns revolving around sandboxing executable code, and how the EVM pushes executable code  (bytecode) to the blockchain. After that, we provide an introduction to Solidity, a programming language  for writing smart contracts in Ethereum. We will explore the syntax of Solidity, and the common integrated  development environments (IDEs) being used to work with it. Next, we focus on the World Computer model  proposed using Ethereum and a few related decentralized technologies such as IPFS and Whisper. Then, we  will look at the apps available in Ethereum. On the enterprise side, a particularly noteworthy development is  the Blockchain-as-a-Service (BaaS) deployed on the Azure cloud by Microsoft. For the network, distributed  apps (Dapps) are being built on top of Ethereum and published using other World-Computer components  such as Mist.
Overview of Ethereum
It was around mid-2013 when a majority of the Bitcoin community was starting to flirt with the idea of other  applications beyond simply currency. Soon, there was a flood of new ideas discussed in online forums.  Some common examples include domain registration, asset insurance, voting, and even Internet of Things  (IoT). After the hype started to fade away, a more serious analysis of the Bitcoin protocol revealed severe  limitations of potential applications that can be built on top of the blockchain.
© Vikram Dhillon, David Metcalf, and Max Hooper 2017 25 V. Dhillon et al., Blockchain Enabled Applications, https://doi.org/10.1007/978-1-4842-3081-7_4
Chapter 4 ■ Unpacking Ethereum
A crucial point of debate was whether a full scripting language should be allowed within the blockchain  or applications should be built with logic residing outside of the blockchain. There were two key issues that  sparked this debate:
•  The scripting language and OPCODES in the Bitcoin protocol were designed to be  very limited in functionality.
•  The protocol itself was not general enough, and alternative currencies such as  Namecoin and others emerged specialized for one specific task. The big question at  the time was this: How can a protocol be generalized such that it becomes future
compatible with applications that we know nothing about?
Eventually, two schools of thought emerged regarding scripting: Traditionally, Satoshi’s paper proposed  keeping the scripting language very limited in functionality. This would avoid the security concerns of  having executable code in the blockchain. In a sense, the blockchain executable code is limited to a handful  of necessary primitives that update the distributed states. The second school of thought was championed  by Vitalik, who thought of the blockchain as more than just a ledger. He envisioned the blockchain as a  computational platform that can execute well-defined functions using contracts and arguments. The design  of EVM allows for complete isolation of the executable code and safe execution of the applications built on  top of the EVM. Let’s begin with the design principles and the core idea behind Ethereum.
■ Core idea Instead of building a platform to support specific applications, in Ethereum, we build to support  a native programming language with extensibility to implement business logic on the platform using that  language.
We return shortly to discuss the implications of this principle. In the meantime, let’s talk about another  feature of Ethereum, consensus. We discussed the concept of consensus in earlier chapters: In PoW-based  cryptocurrencies such as Bitcoin, the network awards miners who solve cryptographic puzzles to validate  transactions and mine new blocks. Ethereum uses a different consensus algorithm called PoS. In a PoS  algorithm, the validator or creator of the next block is chosen in a pseudorandom manner based on the stake  that an account has in the network. Therefore, if you have a higher stake in the network, you have a higher  chance of being selected as a validator. The validator will then forge the next block and get a reward from the  network. Here, the validator is truly forging a block (in the blacksmith sense of the term) instead of mining,  because in PoS, the idea of hardware-based mining has been replaced by this virtual stake. To some extent,  the rationale behind using PoS was due to the high-energy requirements of PoW algorithms that became a  frequent complaint. Peercoin was the first cryptocurrency to launch with PoS, but more prominent recent  PoS implementations can be seen in ShadowCash, Nxt, and Qora. The main differences between Bitcoin and  Ethereum as protocols are highlighted in Figure 4-1.
26
Chapter 4 ■ Unpacking Ethereum

Figure 4-1. Overview of Bitcoin and Ethereum as computational platforms
In the Bitcoin protocol, addresses map the transactions from sender to receiver. The only program that  runs on the blockchain is the transfer program. Given the addreses and the key signature, this program can  transfer money from one user to another. Ethereum generalizes this concept by placing an EVM at every  node so that verifiable code can be executed on the blockchain. Here, the general scheme is that an external  account will pass arguments to a function and the EVM will direct that call to the appropriate contract and  execute the function, granted the appropriate amount of Ether and gas are supplied. As a consequence,  every transaction in Ethereum can be considered a function call. The function calls and transactions in  Ethereum comply with PoS, which has a faster resolution time than the Bitcoin blockchain that relies on  PoW. The security level of this process verified by the network is also very high.
Accounts in Ethereum
Accounts are a metastructure in Ethereum and the fundamental operational unit of the blockchain.  Accounts also serve as a model to store and track information on the users in the network. There are two  types of accounts available on the network.
27
Chapter 4 ■ Unpacking Ethereum
•  User accounts: These are user-controlled accounts also known as external accounts.  These accounts have an Ether balance, are controlled by public–private key pairs,  and can send transactions, but have no associated code. All actions in the Ethereum  network are triggered by transactions intiated by external accounts. In the Bitcoin  protocols, we referred to these simply as addresses. The key difference between
accounts and addresses is the ability to contain and execute generalized code in
Ethereum.
•  Contracts: This is essentially an account controlled by its own code. A contract  account is the functional programmatic unit in Ethereum that resides on the
blockchain. This account has an Ether balance, has associated code, can execute
code when triggered by transactions recieved from other accounts, and can
manipulate its own persistent storage. (Every contract on the blockchain has its own  storage that only it can write to; this is known as the contract's state.) Any member  on the network can create an application with some arbritary rules, defining it as a  contract.
If accounts play such a key role, how are they represented on the blockchain? Accounts become an  element of the merkle trees, which in turn are an element of every block header. Ethereum uses a modified  form of the binary merkle trees called Merkle-Patricia trees. A complete explanation of the Merkle-Patricia  tree (see http://www.emsec.rub.de/media/crypto/attachments/files/2011/04/becker_1.pdf) would be  beyond the scope of this text, but a graphical synopsis is provided in Figure 4-2.
■ Note The two-account system explained here might not remain in Ethereum for the long term. Recently,  there has been a push in the development community toward a one-account model, where user accounts are  implemented by using contracts.
28
Chapter 4 ■ Unpacking Ethereum

Figure 4-2. Overview of block headers and Merkle-Patricia trees for Block A and B
29
Chapter 4 ■ Unpacking Ethereum
The block header contains a few standard definitions that broadcast the status of the network.  Additionally, every block header in Ethereum has three trees for three classes of objects: transactions  (function calls), receipts (the results of a function call, recording the effect of each transaction), and state  objects. We explore the Merkle-Patricia tree further with the state root, which contains account objects.  Binary trees are useful to manage transaction history, but the state has more components and needs to be  updated more frequently. The balance of an account and the nonce for the network are often changed and  therefore what is needed is a data structure where we can quickly calculate a new tree root after an insert,  update, edit, or delete operation without needing to recompute the entire tree. This modified merkle tree  allows for rapid queries to questions such as these: Does this account exist? Has this transaction been  included in a particular block? What is the current balance of my account? The Merkle-Patricia tree shown  in Figure 4-2 is two levels deep and has numerous branches. One of the branches points to a dashed box  containing the four components that make up an account. The balance is only relavent for an external  account, and similarly, the codehash (which holds executable code) is only applicable to contracts. The  storage root actually contains data uploaded by a user to the blockchain or the internal storage space  available to a contract that can be updated as that contract is executed.
State, Storage, and Gas
We briefly mentioned that a contract can manipulate its own storage and update the state, so what is a state?  Recall that in the Bitcoin protocol, data on users and transactions is framed and stored in the context of  UTXOs. Ethereum employs a different design strategy of using a state object. Essentially, the state stores a list  of accounts where each account has a balance, as well as blockchain-specific data (code and data storage).  A transaction is considered valid if the sending account has enough balance to pay for it (avoiding double  spending), therefore the sending account is debited and the receiving account is credited with the value.  If the receiving account has code associated with it, the code will run when the transaction is received.  The execution of a contract or the code associated with an account can have different effects on the state:  Internal storage could also be changed, or the code might even create additional transactions to other  accounts.
Ethereum makes a distinction between state and history in the network. The state is essentially a  snapshot of the current information regarding network state and accounts at a given time. On the other  hand, history is a compilation of all the events that have taken place on the blockchain, such as function calls  (transactions) and the changes brought about as a result (receipts). Most nodes in the Ethereum network  keep a record of the state. More formally, the state is a data structure that contains key value mapping  addresses to account objects. Each account object contains four values:
•  Current nonce value
•  Account balance (in Ethers)
•  Codehash, which contains code in the case of contracts, but remains empty for  external accounts
•  Storage root, which is the root of the Merkle-Patricia tree that contains code and data  stored on the blockchain
30
Chapter 4 ■ Unpacking Ethereum
Next, let’s talk about gas in Ethereum. Gas is the internal unit for keeping track of execution costs in  Ethereum. In other words, it is a microtransaction fee for performing a computation on the blockchain. For  a computational platform like Ethereum, this becomes crucial when running code because of the halting  problem: One cannot tell whether a program will run indefinitely, or just has a long runtime. Gas puts a  limiter on the runtime as the user has to pay for executing step-by-step instructions of a contract. The nature  of microtransactions allows steps to be executed very inexpensively, but even those transations will add  up for very long runtimes. Once the gas supplied for a contract is exhausted, the user would have to pay for  more to continue. Special gas fees are also applied to operations that take up storage.
Operations like storage, memory, and processing all cost gas in the Ethereum network. Let’s talk about  storage next. In Ethereum, external accounts can store data on the blockchain using contracts. A contract  would manage the upload and storage process, but the data types that can be stored currently are very  limited. A natural question then becomes: What are the limits on uploading content and information to  the Ethereum blockchain? What would prevent the bloating of the blockchain? As it turns out, there are  currently two mechanisms in place preventing a data overload:
•  Gas limits per block that dictate how much gas can be spent per block on storage and  computational operations
•  Amount of money a user would have to spend to purchase the gas needed to store  data
The second limitation is usually a deterrent for users to store directly on the blockchain, as it becomes  much more efficienct and economical to use a third-party decentralized serivce like STORJ (https:// storj.io/) or IPFS (https://ipfs.io/) for the storage and hash the location in Ethereum to include it in a  contract. In the future, new distributed storage applications will allow for all sorts of data files to be uploaded  and included in contracts on the blockchain. Let’s summarize what we have discussed so far: We started  with the differences between Bitcoin and Ethereum using accounts, charging gas for operations, storing data  directly on the blockchain, allowing executable code on the blockchain, state objects, and Merkle-Patricia  trees. Figure 4-3 below a simplified functional overview of the processes occuring in Ethereum.
31
Chapter 4 ■ Unpacking Ethereum

Figure 4-3. A simplified overview of the Ethereum network
32
Chapter 4 ■ Unpacking Ethereum
There are three important Ethereum components to discuss: the API, the network, and the blockchain.  The Ethereum JavaScript API (also known as web3.js) provides a large feature set for functionality such as  constructing transactions and contracts, referring to functions, and storing receipts. An enhanced wallet  client for Ethereum such as Mist (https://github.com/ethereum/mist) can take over several of these  functions with a GUI. Once a candidate block is constructed, it is broadcast to the network by the Ethereum  client. The validators on the network determine if the transactions are valid, and if any code (in the block)  associated with a transaction or a contract is valid. Once the validation is complete, the validators execute  the associated code and apply it to the current state. The block is broadcast to the network and a miner will  forge the block, then the verified block is added to the blockchain. This step also creates transaction receipts  for every transaction included in the block. The new block also provides updates to the state objects and  relational links for the state from the current block to a new block.
■ Note What will prevent the Ethereum network from being bloated by small unused contracts? Currently,  there are no mechanisms to control the life span of a contract, however, there are a few proposals in the air  about temporary subscription-based contracts. In the future, there might be two different types of contracts, one  that has a permanent life span (which is significantly more expensive to create and compute), and the other one  that operates until its subscription expires (cheaper and temporary; self-destructs after subscription runs out to  prevent cluttering).
Ethereum Virtual Machine
Formally, EVM is the runtime environment for smart contracts in Ethereum. Contracts are written in a  higher level language called Solidity and then compiled into bytecode using an interpreter in EVM. This  bytecode is then uploaded to the blockchain using an Ethereum client. Contracts live on the blockchain in  this executable bytecode form. The EVM is designed to be completely isolated from the environment and the  rest of the network. The code running inside the EVM has no access to the network or any other processes;  only after being compiled to bytecode do contracts have access to the external world and other contracts.
From an operational standpoint, the EVM behaves as a large decentralized computer with millions of  objects (accounts) that have the ability to maintain an internal database, execute code, and talk to each other  through message passing. This model is not yet complete, but in Ethereum, this concept is often referred to  as the idea of a world computer. Let’s return to the topic of code execution and how it is intimately linked to  consensus. EVM allows any user on the network to execute arbitrary code in a trustless environment where  the outcome is fully deterministic and the execution can be guaranteed. The default execution environment  and settings lead to stasis: Nothing happens on the network and the state of everything remains the same.  However, as we mentioned before, any user can trigger an action by sending a transaction from an external  account. We can have two outcomes here: If the receiver is another external account, then the transaction  will transfer some Ether but nothing else happens. However, if the receiver is a contract, then the contract  becomes activated and executes the code within. Executing code within the network takes time, and the  process is relatively slow and costly. For every step in the instructions, the user is charged gas for execution.  When a user initiates an execution through a transaction, they commit an upper limit for the maximum  currency that they are willing to pay as gas for that contract or code.
33
Chapter 4 ■ Unpacking Ethereum
■ Tip Ethereum has recently begun the process of migrating over to a just-In-time virtual machine (VM),  which offers some optimizations in gas usage and performance.
What does it mean for the outcome of EVM to be deterministic? It is essential for each node to reach  the identical final state given the same input for a contract method. Otherwise, each node that executes  the contract code to validate the transaction would end with different results and no consensus would be  possible. This is the deterministic nature of EVM that allows every node to reach consensus on execution  of a contract and the same final state of accounts. The nodes executing a contract are similar to cogs  synchronized to move inside of a clock, as they work in a harmonious fashion and reach the matching final  state. A contract can also refer to other contracts, but it cannot directly access the internal storage of another  contract. Every contract runs in a dedicated and private instance of the EVM where it only has access to  some input data, its internal storage, the code of other contracts on the blockchain, and various blockchain  parameters such as recent block hashes.
Every full node on the network executes the contract code simultaneously for each transaction. When  a node is validating a block, transactions are executed sequentially, in the order specified by the block.  This is necessary because a block might contain multiple transactions that call the same contract, and the  current state of a contract might depend on state modified by previous references during the code execution.  Executing contract code is relatively expensive, so when nodes receive a block, they only do a basic check  on the transactions: Does the sending account have enough Ether to pay for gas? Does the transaction have  a valid signature? Then, mining nodes perform the relatively expensive task of executing the transaction,  including it in a block, and collecting the transaction fee as a reward. When a full node recieves a block, it  executes the transactions in the block to independently verify the security and integrity of the transactions to  be included in the blockchain. Let’s look at the EVM visually in Figure 4-4.
34
Chapter 4 ■ Unpacking Ethereum

Figure 4-4. Four instances of Ethereum Virtual Machines (EVMs) running on four different nodes
The four EVMs are synchronously executing a contract’s instructions and will arrive at the identical  account state once the execution has been completed. This is due to the deterministic nature of the EVM,  which allows the contract to reach consensus across the network at every step of instructions. The EVM has  a very straightforward rationale: It has a single run loop that will attempt to execute the instruction one step  at a time. Within this loop, the gas is calculated for each instruction and the allocated memory is expanded if  necessary. The loop will continue until the EVM either recieves an exit code indicating successful execution  or throws an exception such as out of gas.
35
Chapter 4 ■ Unpacking Ethereum
Solidity Programming Language
Solidity is a higher level, object-oriented programming language for writing smart contracts in Etheruem.  Any code written in Solidity can be executed on the EVM after being compiled into bytecode, which is an  instruction set for the EVM. How does the bytecode encode references to other functions and contracts that  are called during execution? This is done using an application binary interface (ABI). In general, an ABI is  the interface between two program modules: machine-level instructions and a human-readable higher level  programming language. Let’s break down this answer into three components:
•  Contract: A contract is simply higher level code defined in a formal language such as  Solidity.
•  Compiled contract: The contract is converted to bytecode to be executed on the  EVM, adhering to the compiler specification. Note that function names and input  parameters get hashed and obfuscated during compilation. Therefore, for another  account to call a function, it must have access to the given function name and
arguments, and we need another layer that interfaces encoding into and out of the  bytecode.
•  ABI: An ABI is a list of the contract’s function definition and arguments in JavaScript  Object Notation (JSON) format. The function definitions and input arguments are  hashed into the ABI. This is included in the data of a transaction and interpreted
by the EVM at the target account. An ABI is necessary so that you can specify which  function in the contract to invoke, as well as get a guarantee that the function will
return data in the format you are expecting.
Solidity (see https://solidity.readthedocs.io/en/develop/) has a new plug-in for Visual Studio  (see https://marketplace.visualstudio.com/items?itemName=ConsenSys.Solidity) to help write smart  contracts in a powerful IDE and deploy them to the Ethereum network. Our discussion of Solidity here is  limited to covering the fundamentals, such as storing variables and creating a simple contract, so let’s get  started.
/* defining a contract */
contract ExampleStorage {
 uint storedNumber; //unsigned integer (uint) used to declare a state variable
/* Function set can modify the value of the state variable */
 function set(uint x) {
 storedNumber = x;
 }
/* Function get can retrieve the value of state variable */
 function get() constant returns (uint retVal) {
 return storedData;
 }
}
36
Chapter 4 ■ Unpacking Ethereum
This storage contract allows a user to store an integer as a state variable storedNumber and then modify  or retrieve its value using the get() and set() functions. Solidity also offers several advanced features  available in modern programming languages such as inheritance (for contracts), function overloading, and  class interfaces. Next, let’s look at a more complex example of a contract. This time we create a simple bank  contract using Solidity:
// This bank contract allows deposits, withdrawals, and checking the balance
// 'contract' is a keyword to declare class similar to any other OOP
contract SimpleBank {
// 'mapping' is a dictionary that maps address objects to balances
// 'private' means that other contracts can't directly query balances  mapping (address => uint) private balances;
// 'public' makes externally readable by users or contracts on the blockchain  address public owner;
// Events trigger messages throughout the Ethereum network
 event LogDepositMade(address accountAddress, uint amount);
// Constructor
 function SimpleBank() {
 // msg provides details about the message that's sent to the contract  // msg.sender is the address of contract creator
 owner = msg.sender;
 }
 // Deposit Ether into the bank
 // Returns the balance of the user after a deposit is made
 function deposit() public returns (uint) {
// Add the value being deposited to the account balance
 balances[msg.sender] += msg.value;
// Log the deposit that was just made
 LogDepositMade(msg.sender, msg.value);
// Return the balance after the deposit
 return balances[msg.sender];
 }
// Withdraw Ether from bank
// withdrawAmount is the amount you want to withdraw
// Returns the balance remaining for the user
 function withdraw(uint withdrawAmount) public returns (uint remainingBal) {
37
Chapter 4 ■ Unpacking Ethereum
/* If the account balance is greater than amount requested for withdrawal, subtract it from  the balance */
 if(balances[msg.sender] >= withdrawAmount) {
 balances[msg.sender] -= withdrawAmount;
// Increment the balance back to the original account on fail
 if (!msg.sender.send(withdrawAmount)) {
 balances[msg.sender] += withdrawAmount;
 }
 }
// Return the remaining balance after withdrawal
 return balances[msg.sender];
 }
// Return the balance of the user
// 'constant' prevents function from editing state variables;
 function balance() constant returns (uint) {
 return balances[msg.sender];
 }
}
Although this contract has plenty of moving parts, it has a straightforward schematic: We start by  declaring state variables and here we used an advanced data type called a mapping. Then, we declare an  address variable used throughout the contract and an event logger. The constructor prepares the owner  object to be usable and we attach the owner object to recieve messages in the form of return types from  functions. There are three functions that follow the constructor that allow for the basic functions of a bank.  The deposit function adds the argument amount to the balance. The withdrawal function checks whether  the requested amount is lower than the balance available for an account. If this is the case, the withdrawal  is confirmed and the argument amount is subtracted from the balance. If there is not enough balance, the  amount that was supposed to be withdrawn is added back to the account and the final balance is returned to  the user. Finally, the last function allows us to return the balance of an account at a given time as requested  by the contract.
World Computer
The Ethereum project has a grand vision of becoming a shared world computer with millions of accounts,  powered by the blockchain, which becomes a back-end for smart-logging of communications. Contracts  provide the decentralized logic to be executed and EVMs are the execution platform. Computation and  processing are not enough, though; a computer must also be able to store information and allow for a  mechanism for applications to communicate among each other. This world computer, depicted in Figure 4-5,  would operate in an Internet 3.0 era, where servers are no longer needed due to the decentralized nature of  information flow. In this ambitious endeavour, Ethereum is only one third of the project, so let’s introduce  the other two components:
•  Whisper: A message-passing protocol that allows decentralized applications and  accounts on the blockchain to communicate with each other. This is different from  traditional message passing protocols where applications execute on the same
machine; here, the decentralized apps can execute on any node in the blockchain.
38
Chapter 4 ■ Unpacking Ethereum
•  Swarm: A decentralized data storage and distribution resource available to the  Ethereum blockchain. Swarm is a peer-to-peer data sharing network where files  are addressed by the hash value of their content. This resource is very similar to  BitTorrent, where data can be fetched from multiple nodes (called peers) that host  small pieces of a file(s), and they are put together by the receiving party. Swarm’s  most powerful feature is that if even a single node hosts a piece of data, it can be  accessed from anywhere within the network. Currently, Swarm is in the early stages  of development and doesn’t specify one service (Storj, IPFS) that will provide  decentralized storage; however, Swarm does have the tools to handle storage and  hashed references to the data stored off-blockchain. Using Swarm makes it possible  to distribute data across the network to replicate redundancy in a decentralized  fashion without having to host any kind of server. Multiple nodes in the network  can be incentivized to replicate and store the data, much like a RAID configuration,  eliminating the need for hosting servers in the network.
•  Contracts: These are the final component of the world computer that we mentioend  previously. They allow programmatic access to the blockchain and provide the  logical framework to power applications that will eventually run on the world  computer.
39
Chapter 4 ■ Unpacking Ethereum

Figure 4-5. A layered approach to the world computer model in Ethereum
40
Chapter 4 ■ Unpacking Ethereum
User accounts (or simply users) on the world computer are fundamental entities in the world computer,  so users are the first layer. The second layer is the blockchain, which serves as a communication serial bus  between the different components in the network. The third layer is the logical framework called smart  contracts that reside on the blockchain, and provide the computational capabilities to the world computer.  Some of these contracts might require external storage for output and use Swarm to coordinate storage,  which is the fourth layer. Finally, looking back at the first layer, we have the message passing protocol called  Whisper to facilitate user-to-user or application-to-application communication.
More than a philosophical vision or a technological blueprint, the concept of a world computer and  Internet 3.0 have some far-reaching implications for how content is controlled and distributed across the  Web. Taylor Gerring from Ethereum spoke very eloquently about building this dream:
As economics of the Ethereum ecosystem mature such that open contracts for lowest rate storage develop, a free market of content hosting could evolve. Given the nature and  dynamics of P2P applications, popular content will readily scale as the swarm shares,  rather than suffering from the buckling load of siloed servers. The net result is that popular  content is delivered faster, not slower.
This metamorphosis will offer developers an opportunity to build the next-generation  of decentralized, private, secure, censorship-resistant platforms that return control to  creators and consumers of the next best idea. Anyone with a dream is free to build on this  new class of next-generation decentralized web services without owning a credit card or  signing up for any accounts.
Although we are not told to or expected to, we have an imperative to cherish and improve  the very shared resources that some wish to disturb, manipulate, and control. Just as no  single person fully understands the emerging internet collective intelligence, we should not  expect any single entity to fully understand or maintain perfectly aligned motives. Rather,  we should rely on the internet to solve the problems of the internet.
Blockchain-as-a-Service
Microsoft recently announced a partnership with the Ethereum Foundation to launch a blockchain-based  service on their cloud platform Azure. This Infrastructure-as-a-Service approach to offering fast and easy  implementations of blockchain will allow developers to experiment with new features and deploy DApps at  reduced costs. Marley Grey from the Azure Blockchain Engineering team described how Blockchain-as-a Serivce (BaaS) will foster an ecosystem of DApps:
Microsoft and ConsenSys are partnering to offer Ethereum Blockchain as a Service  (E-BaaS) on Microsoft Azure so Enterprise clients and developers can have a single-click  cloud-based blockchain developer environment. The initial offering contains two tools  that allow for rapid development of SmartContract based applications: Ether.Camp,  an integrated developer environment, and BlockApps, a private, semiprivate Ethereum  blockchain environment, can deploy into the public Ethereum environment.
“Ethereum Blockchain as a Service” provided by Microsoft Azure and ConsenSys allows  for financial services customers and partners to play, learn, and fail fast at a low cost in a  ready-made dev/test/production environment. It will allow them to create private, public  and consortium based Blockchain environments using industry leading frameworks  very quickly, distributing their Blockchain products with Azure’s World Wide distributed
41
Chapter 4 ■ Unpacking Ethereum
(private) platform. That makes Azure a great Dev/Test/Production Environment for  Blockchain applications. Surrounding capabilities like Cortana Analytics (machine  learning), Power BI, Azure Active Directory, O365 and CRMOL can be integrated into  apps launching a new generation of decentralized cross-platform applications.
This initial update on BaaS was provided at the end of 2015 and currently a whole ecosystem of Blockchain  Labs is flourishing within the Azure DevTest community. The DevTest Labs allow users and developers to  explore and test a template designed for a specific use case. In addition, the platform began with Ethereum  blockchains but recently more startups have started to build on Azure, offering new services such as Emercoin,  which offered an SSH service, and PokiDot, with its health-care-oriented blockchain called Dokchain. Over  time, more startups have begun using Azure as the standard to run a blockchain and build applications on top.  With the integration of intelligent services such as Cortana, it might become easier to develop oracles that can  sign incoming data from external streams (e.g., IoT devices) and provide a level of integrity.
■ Note Two recent developments from Microsoft in the BaaS space are noteworthy here. The first is  introduction of Cryptlets, a secure middleware to interface with external events for building enterprise smart  contracts. The second development is the Coco framework. An open-source system for building a high throughput  network on top of a blockchain, where nodes and actors are explicitly declared and controlled. By design, Coco is  compatible with any ledger protocol, and would allow enterprises to build production-ready blockchain networks.
Decentralized Applications
We alluded to DApps in our discussion of Whisper, but we will talk about them in more depth here. A  DApp is a serverless application that runs on the Ethereum stack and interfaces with the end user via an  HTML/JavaScript front end that can make calls to the back-end stack. Clasically, a mobile or web app has  a back end running on centralized dedicated servers; however, a DApp has its back-end code running on a  decentralized peer-to-peer network. The structure of a DApp is shown in Figure 4-6.
Figure 4-6. Structure of a DApp
The user interace is often written in HTML or JavaScript and it is the only component loaded on a user  device. The interface makes back-end calls to the blockchain to execute a particular contract and also to the  back-end resources such as Swarm or Whisper if external storage is needed or when the application needs to  communicate with other apps.
42
Chapter 4 ■ Unpacking Ethereum
If a traditional app is made up of a front end and a server running the back end, then a DApp running  on the Ethereum stack would be made up from a front end and contracts running on the blockchain. DApps  usually have their own set of associated contracts on the blockchain that are used to encode business logic  and allow persistent storage of their consensus-critical state. Recall that all code on the Ethereum stack runs  within an EVM that keeps track of step-by-step operations and charges gas to the owner of a contract. This  prevents DApp developers from running too many operations on the blockchain or bloating it by storing  data directly on the blockchain.
■ Note To briefly review, the Ethereum stack is made of three components: the blockchain, Whisper, and  Swarm. The front-end interface makes calls to the blockchain to specific contracts running the DApp based on  user actions.
How does the back end of a DApp pull static content for the front end such as JavaScript from the  Ethereum stack to static content and receive the updated global state from the blockchain? Let’s look at an  example using IPFS as storage to understand these back-end calls, as depicted in Figure 4-7.
•  The back-end code is essentially a contract that executes on the blockchain given the  appropriate amount of resources.
•  Some applications need to use a persistent database to host static content used in  the app. We can rely on IPFS that stores static files, hosted throughout the network  on several nodes.
•  Hashes from IPFS are delivered to the DApp and the contract’s execution updates the  global state, which is deliverd to the DApp from the Ethereum stack.
Figure 4-7. A simple schematic of back-end calls made by a DApp
The blockchain can deposit content to an IPFS-like system on one of the nodes and the hashes can be  made available to the app for retrieval when necessary. The app can request updates from the blockchain  on the global state as it affects the app running on a device. Finally, as needed, the app can retrieve and  download full content from the decentralized storage to the user device. Splitting up roles in this manner  allows for more innovative user interfaces, as a developer can switch it out, not having to change the back  end at all.
43
Chapter 4 ■ Unpacking Ethereum
Geth and Mist
There are two more tools we need to discuss briefly that play a role in DApp develpoment. Geth is the  command-line interface (written in Go-lang) for running a full node on the Ethereum network. Using Geth,  you can interact with the Ethereum network and perform tasks such as:
•  Mine Ether on the network
•  Transfer funds between addresses
•  Create contracts and send transactions
•  Use the DApps API
Geth comes with two interfaces that are used in development: The JavaScript console with web3.js  library, and the JSON-RPC server. Let’s talk about both technologies briefly. Geth can be launched with  an interactive console that provides the JavaScript runtime environment for you to interact with a node.  This runtime environment includes the web3 library, which can construct contracts and transactions to be
propagated to the node. The JSON-RPC server is a remote procedure call (RPC) protocol that facilitates data  exchange between the node and its clients (JSON is a data-exchange format that nodes use to communicate  with clients). More precisely, RPC is a collection of methods and rules that define how data (commands and  output) can be transferred between a node and a client. The JavaScript API uses the web3.js library to offer a  convenient interface for using the RPC methods.
■ Tip For most Ethereum applications today, Geth is a prerequisite for installation as a command-line tool.  Often, during the installation, Geth is provided as an add-on so that a user doesn't have to download and install  it separately.
The second tool is called the Mist DApp browser. In early discussions, Mist was conceptualized to  be a stand-alone app-store-type browser for DApps, but that vision has evolved. Mist is still in heavy  development; however, the release plan is to bundle Mist together with the Ethereum wallet to make a  powerful tool. In future releases, the wallet will just be a single DApp running on the Mist browser. Soon the  browser will be able to open any DApp available and the wallet will just be one app among them.
Eventually, the most powerful entitites on the Ethereum network using Geth and Mist will be  decentralized autonomous organizations (DAOs), which are essentially automated companies powered by  smart contracts that run on the Ethereum network. We end our journey exploring Ethereum here and pick  up our discussion of DAOs in the next chapter.
Summary
In this chapter, we introduced Ethereum, one of the biggest alternate currencies competing against  Bitcoin. In recent years, it has gained a very serious focus from developers and investors. We began our  discussion here with a broad overview of what Ethereum is in comparison to Bitcoin. We talked about  accounts and function calls as being foundational to Ethereum. We then provided some more depth to the  ideas of accounts as entities on the blockchain. After that, we discuss the use of gas on Ethereum for smart  contract execution, how internal storage is adapted to work with Merkel-Patricia trees, and the concept of  internal state for an account. After that, we talked about EVM and how smart contracts are executed on the
44
Chapter 4 ■ Unpacking Ethereum
blockchain. Then, we discussed a model for writing smart contracts using Solidity and applying a plug-in  for Visual Studio to rapidly prototype smart contracts. Finally, we talked about the world computer model  as it applies to Ethereum components such as IPFS and Whisper. We ended the discussion with a short  description of all the components in the world computer.
References
The main reference material used to prepare this chapter was Ethereum Homestead developer  documentation and Solidity documentation. A detailed list of references is given at the end of the book.
45
CHAPTER 5
Decentralized Organizations
Bitcoin can be thought of as the first prototypical decentralized autonomous organization (DAO). It created  a network-based ecosystem of participants who contributed computational power toward a singular goal. In  Bitcoin, the distributed protocol providing a financial service and rewarding miners became a rudimentary  decentralized organization. In this chapter, we talk about more complex and full DAOs made in Aragon.  Aragon (https://aragon.one/) is a decentralized application (DApp) that lets anyone create and manage  different kinds of organizations (nongovernmental organizations [NGOs], nonprofits, foundations) on  the Ethereum blockchain. Creating a DAO requires numerous steps and originally it was more difficult to  implement in Ethereum. However, Aragon implements all the basic features of an organization in a base  template that is deployed whenever a user instantiates a company. Most of the traditional features such as a  cap table, voting, fundraising, and accounting are offered in Aragon as a decentralized counterpart to run on  the blockchain. In addition, an Aragon company can be customized to a very granular extent and extended  using new modules that can be added to a company’s existing smart contracts. Aragon enables different  organizations to be built on the blockchain, and one interesting use case integrates identity using a two way verification scheme with Keybase. We talk about how the Keybase to Aragon peg functions to provide  identity services in the context of a decentralized system. We also briefly go over the Aragon kernel, which  is essentially a task manager with subroutines that ensure smooth communication within an organization,  among its members, and in the underlying blockchain.
We begin our discussion with the Aragon kernel and it’s main functions. Then, we take two approaches  in defining a DAO: A definition in terms of consensus between members, and a definition focusing on  features given by Ralph Merkel. Aragon-core has adopted the latter definition, and extended it to “organs”,  so we go through all the organs available to Aragon-core. The heart of this chapter is a set of visual tutorials  split into three topics. The first topic introduces users to the basics of an Aragon company and how to set  up a MetaMask wallet. This topic ends with users having set up a default company and a functional wallet.  The second topic dives into understanding the daily operations of your newly created company. This  covers stocks and stock classes available in Aragon, user permissions, and tokens. A variety of operations  are demonstrated here, such as adding new stock classes, issuing shares, assigning stocks to a new hire,  assigning a role to a new employee, and transferring existing tokens within the company. The third topic  focuses on more advanced topics in Aragon. Here, we discuss fundraising on the Ethereum blockchain using  Aragon and the different types of rounds implemented in Aragon. Finally, we conclude the tutorial and this  chapter with a discussion of bylaws and how to edit the default company template deployed by Aragon.
© Vikram Dhillon, David Metcalf, and Max Hooper 2017 47 V. Dhillon et al., Blockchain Enabled Applications, https://doi.org/10.1007/978-1-4842-3081-7_5
Chapter 5 ■ Decentralized Organizations
Aragon Kernel
The kernel in Aragon serves as a switchboard directing requests and message passing to the various  subroutines (also called organs). In production mode, the kernel will be concurrently interfacing with  hundreds of Aragon organizations or users on the blockchain. Here, our focus is limited to the kernel  interacting with just one company: a DAO. What is a DAO? A DAO is a blockhcain entity built on a consensus  of decisions by its members. A DAO brings the concept of consensus inherent to the blockchain to include  decisions and choices made by members of a DAO that have a stake in it (usually in the form of DAO tokens).  As such, a DAO is built with automation at its core and members at the periphery that rely on a majority-based  consensus to make decisions for the organization. Although this definition of a DAO is a general descriptor, it  is incomplete. Perhaps a better approach to defining a DAO would be through the functions it performs. The  concept for a DAO was originally derived from Bitcoin, which might be viewed as the first prototype for a DAO.
■ Note The simplest functional unit on an Aragon network is a DAO and therefore the majority of our  discussion is focused around a minimal use case. Aragon provides a base template that can be used to set up a  DAO and you can modify this template to set up a custom set of rules. Other types of organizations (e.g., NGOs  or nonprofits) are built on the base template with significant modifications that allow a new modus operandi.  Additionally, throughout the remainder of this chapter, the terms DAO, company, and organization are used  interchangeably to represent the same concept.
Ralph Merkle talks about a DAO as an entity that owns internal property that has value, can update its  internal state, is responsive to the members, and runs smart contracts. These are some of the most basic  functions that any DAO should be able to perform, but currently there are no compliance standards (like the  ERC20 for tokens) for DAOs. The kernel uses a set of organs to carry out most of its daily activities. Let’s go  through the organs provided by default in Aragon:
•  Meta organ: A self-aware (in terms of internal state) and self-actionable organ that is  responsible for updating the DAO internally in response to actions by the members or
externally. This organ also maintains a global registry of organs operating within the kernel.
•  Dispatch organ: A validator organ that determines whether a requested action or a  transaction can be carried out on behalf of the requestor. This can be done through  an oracle, or programmed logic that filters requests based on specific criteria. The  outcome of the dispatch organ is a simple pass or fail. If an action fails, it will not
be carried out. However, if an action or transaction passes, it will be dispatched
to a more appropriate organ for processing or execution. The dispatch organ also
maintains a list of priorities for each request to be triaged and directed appropriately.
•  Vault organ: The vault organ serves as a collective wallet for the DAO. It stores the  funds owned by the DAO as tokens and approves any spending requests.
•  Token organ: The token organ specifically deals with governance tokens allocated to  the members of DAO. This organ also contains the operational logic for adding new  types of tokens or replacing and removing older tokens.
•  Applications organ: This is the smart contract collective that operates at the core of  a DAO. The applications running in this organ are sandboxed from the remainder  of the organization, but most of the business logic resides in this organ. Aragon
provides a basic set of Ethereum contracts responsible for default actions, but this  organ is extensible. New applications or modules can be added to the organization to  increase functionality to satisfy specific use cases.
48
Chapter 5 ■ Decentralized Organizations
Identity Management
The concept of identity is a conundrum for cryptotechnologies because it requires a certain level of trust to be  inherent in the network architecture. Most generalized approaches toward integrating identity in a consensus based system involve some variation of cryptographic proofs and signatures. In Aragon, an external service  called Keybase along with a registry contract are used to establish a “trustless” two-way verification scheme.  The logic behind this scheme is very straightforward: Establish that a particular address belongs to you, and  then verify that your username owns the address. How do these two statements reconcile in a functional  setting? Let’s introduce the two components that make a two-way bridge possible. In simple terms, Keybase is a  public–private key pair management service with OAuth integrations that allow a user to authenticate and verify  accounts. Keybase can serve as a centralized hub for a user to link and verify external accounts. For instance,  after creating an account on Keybase, the public profile of a user can display all the linked social media accounts  establishing their legitimacy and connection. The second component is a registry contract that provides an  account-to-address association mechanism from within the Aragon network. The two-way bridge forms from  using the address (linked to an account on the network) to cryptographically sign a file that can then be hosted  on Keybase (linked to user identity through various social media integrations).
■ Note It is crucial to keep in mind that in Aragon, identity is an opt-in feature. The use cases developed  for Aragon range from providing complete anonymity, as in the case of a DAO, to full usernames integrating  Keybase for a next-generation blockchain company.
So how would users make their identity available to the two-way verification scheme? The workflow  in Keybase Registry 2.0 has been simplified to one simple step: Upload the signed proof to the Keybase  Filesytem (KBFS). This introduces a few new components.
•  Keybase Filesystem: KBFS is a cryptographically secure local and cloud storage  directory. KBFS only allows the owner of the directory to add new files, and these
files are made available publicly. In KBFS, every file added to the directory is
automatically signed by the owner’s private key and the signature can be verified by  anyone through Keybase.
•  Signed proof: Aragon uses a standard proof of identity signed by the user uploaded to  the KBFS public directory. There are four components of this proof: the username on  Keybase, the Ethereum account address owned by the user, a string or comment by  the user, and finally the public key of the signature. Anyone who wishes to verify an  identity can obtain this proof file and use a function such as getUsername(args) to  perform a username reverse lookup given the account address in the proof.
•  Oraclize: The reverse lookup is an on-chain verification process performed through  the registry contract within the Aragon network. For Keybase lookup, a data carrier  service called oraclize is used. Oraclize requests the signature for a given Keybase  username and creates a mapping of the username to an Ethereum account address.  The signature on this proof file should validate with the user’s public key on the
network. Oraclize performs an on-chain check to verify the proof signature and
ensure that the mapping is legitimate. The party initiating this verification on behalf  of another user also has to pay for the steps, including oraclize reference calls.
•  Keybase Resolver: The Ethereum Name Service (ENS) allows us to resolve human readable links into Ethereum addresses. Recently, Aragon has begun testing a
Keybase resolver that will map callbacks to usernames into addresses such that
john.keybase.eth -> 0x99...cx88. This simplifies the reverse lookups and
username references throughout the network.
49
Chapter 5 ■ Decentralized Organizations
DAO/Company Walkthrough
In this section, we go through the process of creating a DAO and becoming familiar with the major DAO  operations in Aragon. For the sake of simplicity, we will only have two entities participating in this DAO, an  executive and an employee. This walkthrough is split into three topics:
•  Setting up a DAO: We introduce the participants of this DAO, show how to create a  wallet, and get familiar with the interface.
•  Creating stocks and assigning shares: After our DAO has been set up, we create new  stock classes, issue new stock, and assign shares to the other entity.
•  Fundraising and editing bylaws: After shares have been assigned, we look at how  fundraising works in Aragon. A DAO can raise funds from a specific investor in
return for stocks, or publicly offer stock to raise a round of funding. We review the  fundraising process, and more important, the bylaws that govern the DAO.
Setting Up a DAO
Download the Aragon client from https://aragon.one/. This client has two main components: Aragon  Core and MetaMask. In each client, Aragon Core functions as an administrative dashboard for the DAO. The  main purpose of this component is directing access control of all entities participating in a DAO. Depending  on your role and if you hold any stock, you might have access to the advanced features. We see later how this  access to features can change by editing the bylaws. The second component is MetaMask, a digital wallet  designed as a plug-in for Google Chrome to make Ethereum accessible to pragmatic daily users. MetaMask  was chosen for Aragon to drive adoption by bringing an already familiar interface to the user. The opening  screen, shown in Figure 5-1, provides a brief introduction to Aragon, along with the wallet setup.

Figure 5-1. The Aragon setup screen. A brief introduction to Aragon is provided here, along with a button to  create a MetaMask wallet. On the top right of the screen there is an icon to access the wallet.
50
Chapter 5 ■ Decentralized Organizations
MetaMask first asks you to create a password for your wallet, as shown in Figure 5-2. This will be your  access key. After entering the password, you will be provided with a passphrase to recover your wallet in case  you lose your password.

Figure 5-2. Creating a password for your MetaMask wallet. Every major step in Aragon is followed by a series  of confirmations that broadcast new changes to the network in the form of transactions.
■ Note Aragon is still connected to a testnet to illustrate the concept. As a result, for some steps, you might  need to verify and confirm transactions multiple times to ensure the initial company creation steps. Some of the  bugs are known and under active development in the beta code.
After creating a wallet password and confirming the transactions, you should see a confirmation screen  and the state of your current wallet (see Figure 5-3). Here is a quick note about Aragon’s alpha releases:  Currently the Aragon client does not operate on the Aragon network. It is connected to an Ethereum testnet  (Kovan Test Net in this case, as shown in Figure 5-3), which serves as a testing ground for Aragon. On a  testnet, currency holds no value, so users can test the product and report any serious bugs, assisting in  product development. A user can request test ETH to be sent to their wallet and experiment with Aragon  without any consequences. That’s why when the wallet is created, it already comes loaded with a balance.
51
Chapter 5 ■ Decentralized Organizations

Figure 5-3. Wallet created using MetaMask. Notice the wallet address shown below along with the balance it  has on the testnet.
The screen after wallet creation brings you to Aragon Core, and there are two options available: Create  a New Organization and Join an Existing Organization, shown in Figure 5-4. From here on, the walkthrough  focuses on the first option, and Aragon is presented from the point of view of an executive. However, we  briefly touch on how users can join a DAO and the level of access available to a regular employee.
Figure 5-4. Aragon Core Welcome screen
The two options provided to a user are not limited to just DAOs; rather, any type of organization can be  built on Aragon, including NGOs and nonprofits. Traditional companies would take a new decentralized  outlook on the Aragon blockchain, but ultimately it is up to the companies to decide which components can  be decentralized. We will select Create a New Organization here. Creating a new company costs Ether, paid  with the wallet we created in the previous step. Then, the transactions are broadcast to the blockchain by  confirming them. Aragon uses a general template to deploy a company on the blockchain, but the founders  can edit this template by changing bylaws. A circular progress indicator in the top right corner shows the  transactions being verified for company deployment.
After the company has been deployed, the next screen is the Aragon Core dashboard. This is where a  user (executive or employee) handles the daily operations of a DAO, with functionss to participate in voting,  assign shares, and more. The dashboard displays the welcome screen by default to the user. To navigate this  dashboard, let’s begin by looking at your profile under Settings (Figure 5-5).
52
Chapter 5 ■ Decentralized Organizations

Figure 5-5. Settings in Aragon Core dashboard
Each account is assigned an address and a username on the network. This address is also associated  with the funds available to the account through the wallet. Under the address is the role of this user. Next,  the Settings screen shows some information about the company we created in earlier steps. The address for  the company is given shown, and a founder would share this address with an employee so that he or she can  join the organization. Recall the two choices from Figure 5-4. To join an organization, a user would enter  the address given in the Company Address field. Below that, under Ethereum Account, is information on  the user connected to this Aragon client. This address matches the one shown at the top right of that page,  but here, we also see the remaining balance in that account. You can also rename this account or log out of  this company. The more interesting tidbit is shown below the Ethereum Account information, an option to  link your account and verify your identity. As we mentioned earlier, not all companies built on Aragon will  take the form of a DAO and some might require verification of the participants. Aragon provides access to an  Ethereum-Keybase resolver for identity management in specific use cases. Finally, the rest of the features in  Aragon Core are accessible through the side menu.
The Settings in Aragon only provide an overview of the user connected to the client, but what’s the  default state of the company we just created? To get an overview of our DAO, we need to navigate to the  Ownership tab shown in Figure 5-6.
53
Chapter 5 ■ Decentralized Organizations

Figure 5-6. Overview of our DAO
Essentially, each participant of the DAO will have a stake in decision making, and this page provides  the amount of stock each party owns. By default, the creator of a DAO initially owns all the stock. We can see  the ownership distribution on the right side of the page, where Me is the current user, and on the pie chart,  Me owns 100 percent of the stock. Currently, there is only one type of stock in the template, Class of Voting  Stock (CVS), which allows the holder to participate in voting. Generally speaking, the more stock you own,  the more influence you can exert on the voting process, but these effects diminish in a DAO with a large  number of users. More precisely, the Voting Distribution section shows how the voting power is distributed  among the entities in our DAO. We only have one user for now, but this chart will update as new users are  added. Next, in this DAO the Shareholder list enumerates the shareholders and currently there are two,  the company itself and the creator (executive, “Me”). The only stock class available is the voting stock, to  which we will add more soon. Finally, the Ownership tab also allows us to perform advanced functions (e.g.,  issuing stock) that can be reached through the menu icon in the top right, which is the focus of the second  topic in our walkthrough.
Issuing Shares
Now that we have our generic company operational, it’s time to start editing the template and customizing  the DAO. We explore here how to issue stock, add new types of shares, and assign them to an employee.  In Aragon, every action that deals with changing the company's operation relies on members reaching a  consensus through majority voting. The default settings give every shareholder voting power, but this can be  refined by editing the bylaws. Let’s begin by issuing shares to the DAO.
54
Chapter 5 ■ Decentralized Organizations
■ Note One interesting use case for a company (or a DAO) in Aragon is to be used as a decentralized  decision-making body for an open source project or an associated technology. The stocks become a mechanism  for decision making for future directions of the project with greater community involvement through voting.  The use of tokens and the ability to raise funds also provides a mechanism for providing monetary support to  sustain development. We revisit this scenario later in this chapter.
Referring to Figure 5-6, use the menu available in the top right to select Issue Shares to open a screen on  the side. Issuing new shares will require us to pick a class of shares to offer and the number of shares to issue.  The process is shown in Figure 5-7.

Figure 5-7. Issuing more shares
First, we have to decide the class of shares to issue. Currently, there is only one class of shares available,  so we will use the default. Next, we choose to issue 100 new shares of the CVS type. To finalize this action, we  first have to go through a voting process. Recall that all major changes to the company need to be reviewed  by other shareholders and approved before an action can be carried out. Here, additional shares will only  be issued if the notion receives at least 50 percent approval from shareholders. Only after that, the company  gains more shares that can be reassigned to other users.
55
Chapter 5 ■ Decentralized Organizations
Currently there is only one voting user in the DAO, so this will be the deciding vote. The voting interface  looks like the general schematic for the voting process shown in Figure 5-8.

Figure 5-8. The voting interface
It follows a very straightforward outline, beginning with the name of the notion bring brought to voters’  attention. This is followed by the action being taken in response and a tentative schedule of the voting. The  default setting for Aragon is to pass a notion with more than 50 percent approval. The interface next displays  who put forth this notion for voting; here Me refers to the user connected to this Aragon client, along with  the user’s address. The details of voting are shown next. Here only one vote is needed to approve the notion.  Finally, the user is presented with two choices: Approve and Reject. After the vote has been cast, it will be  gathered in a transaction. When the poll closes, all the votes will automatically be counted and the outcome  displayed.
56
Chapter 5 ■ Decentralized Organizations
So what does the voting outcome look like? Here, we assume the choice was to approve the notion for  our DAO. Figure 5-9 shows the outcome of the vote.

Figure 5-9. Outcome of voting. The proposition has been accepted and voting is closed. The overall statistics  on voting are reported so any user can see how the vote was split
Issuing more shares just changed the ownership distribution in our DAO. By default, newly issued  shares belong to the company and then executives can vote to transfer those shares to other users as they see  fit. Figure 5-10 shows the new distribution after shares have been issued. Compare this to Figure 5-6 when  the company was just instantiated. Recall that until now, we have only had one stock class, so the global  distribution of shares changes but there are no changes in the stock types. Let’s add new classes of stocks  and explore the options associated with them.
57
Chapter 5 ■ Decentralized Organizations

Figure 5-10. A composite of the changes in ownership distribution with new shares issued
Notice that the new shares are issued directly to the company, not any particular user. Notice also the  changes in the global distribution pie chart. Previously, the Me stake was the only visible portion of the  chart. Now, with the new updates, the company holds a majority of the shares.
Before we add new stock types to our DAO, let’s briefly talk about the different types of stock typically  issued by a public company. There are three major types that we consider here:
•  Common stock (Class A): This is what people normally refer to when they mention  stocks. Common stock is issued by a company and usually available through stock  exchanges such as the New York Stock Exchange (NYSE) or Nasdaq. The main
advantages of common stock are payment in dividends and trade in an exchange. A  dividend is typically a sum of money paid to the shareholders of a company at the  end of a quarter out of the profits generated in that quarter. Common stock can be  also be traded or sold at any time on an accredited exchange.
•  Preferred stock (Class B): Preferred stock is a special kind of stock issued to investors  who have a significant stake in the company. This stock has a few financial
advantages over common stock, making it a safer investment. In terms of dividends,  preferred stock is cashed before common stock and as a result receives a larger share  of a company’s profits as compared to common stock. Moreover, common stock can  vary in terms of dividends paid out, whereas preferred stock provides fixed returns to  the shareholders.
•  Founder stock (Class F): Class F shares are an exclusive kind of preferred stock issued  to founders of a company. These shares come with greater voting rights; for instance,  one share of founder stock might counts for ten votes. In comparison, one share of  common stock would only account for one vote. Founder stock grants super voting  rights and is normally used to retain control of a company’s decision-making process  when a large number of entities are involved.
58
Chapter 5 ■ Decentralized Organizations
Let’s look at the stock classes offered in Aragon. This can be done through the Ownership tab we saw in  Figure 5-6. Click Add Stock Class to open the dialog box shown in Figure 5-11.

Figure 5-11. Interface for adding new stock
There are four stock classes available in Aragon, listed under Stock Templates. Voting stock is the  default, non-voting stock may be issued to attract employees to a company where holding stock becomes an  economic multiplier, founders stock offers super voting rights and often remains concentrated among the  founders, and finally unicorn stock is given to special investors who have a significant stake in the company  because it offers a high multiplier and voting power. Next we assign the parameters of our new stock class.  We will add a class of founder stock that will be indicated in the ownership with the symbol ARN-c. By  default, founder stock has higher voting power than common stock, but that can be updated as necessary.  The Economic Rights setting is a multiplier for the stockholder; essentially, the dividends paid back to this  stockholder are multiplied by their economic right. Next is the number of shares issued. In this case, we want  to add a founder class, and issue 30 new founder shares to the company. As usual, adding a new stock class  would require a vote to be cast (16) and then the new shares would be made available.
59
Chapter 5 ■ Decentralized Organizations
What does the new stock distribution look like? Figure 5-12 shows the addition of a new stock, and the  changes are visible in the Stock Types pie chart.

Figure 5-12. Founder stock added. ARN-c is used as the symbol, and all current shares are owned by the  company. To assign shares to members, a vote would have to be taken
Next, we add another user to our DAO. The second user will be added as an employee and then  assigned some shares. We can also show how an existing shareholder can reward another user with exclusive  shares for their excellent work or a promotion. To add a new member to your organization, you would have  to provide a user with the company address shown in Figure 5-5. They need to download Aragon and join  your organization in the first steps after creating a wallet. After a new member joins, he or she can see the  current state of the company through the Ownership settings. Figure 5-13 shows the process of assigning a  role to a new user after that user has joined your organization.
■ Note The terms organization, company, and DAO are being used interchangeably throughout this  walkthrough.
60
Chapter 5 ■ Decentralized Organizations

Figure 5-13. Assigning role to a new employee in the organization
The Roles tab shown in Figure 5-13 provides an overview of all the entities in the company. Currently,  only one user is present: Me is the user connected to this Aragon client. To assign a new role, click Assign  a Role to open the Assign Role dialog box. The recipient can be added by their username or an account  address in the Recipient field. Depending on your company’s policies, if you require some level of  identification to be associated with your members, you can add those users by referring to their username.  If you don’t use the Keybase identity registry, you would have to add new users by referring to an  address. After inputting the address, you can decide on the role for a user. Here, we are adding a new  employee; however, there are other options available, such as adding a new executive, another employee,  or a superuser. The superuser role is normally reserved for nonhuman entities that are a part of your  organization, such as oracles or a factory entity that can deploy other components of your company.  As always, assigning a new role to a user would require a vote to be cast before the role can be confirmed.
So far, we have discussed how to issue new shares, assign stock, add new stock classes, and assign roles  to new members of your company. Here is an exercise for you: Building on the current state of our DAO,  add a nonvoting stock class with an economic multiplier of 5, and issue 1,000 shares to the company. Then,  assign five of those shares to the new employee, Summer Snow. The result should look like Figure 5-14.
61
Chapter 5 ■ Decentralized Organizations

Figure 5-14. Assigning shares to a new user
The reader exercise should result in a new stock class called, ARN-b which is a non-voting stock. There  should be 1,000 shares issued and by default, all the shares belong to the company. Next, we want to assign  shares, which can be done on the Ownership tab. We have to refer to Summer Snow by an address, then pick  the stock class and the number of shares to be assigned. To approve this change, we normally need a vote. In  this case, however, the non-voting stock has an exception: An executive can grant non-voting stock instantly  to another employee without any need for approval. This is limited only to assigning non-voting stock within  a company, but this exception can be removed by editing the bylaws.
Here are two more tasks: Assign half of the founders stock to yourself, and transfer 1 founders share  to Summer Snow. Both tasks can be performed on the Ownership tab and the final ownership distribution  should look like Figure 5-15. The transfer process can also be completely instantly without any voting, but  this action is irreversible.
62
Chapter 5 ■ Decentralized Organizations

Figure 5-15. Final ownership distribution at the end of all the steps performed
The Ownership tab organizes the shareholders by the stock classes they own. To review, we have three  classes of stock available now: a non-voting stock (ARN-c), a CVS, and founders stock (ARN-b). The majority  of shares with voting power are still owned by the executive, but transferring stock to the employee makes  them eligible to participate in voting. On the right side are the newly updated pie charts for voting and global  distribution of stock within the company. These common operations allow your company to serve as a  governing body and collaboratively determine the future direction of an attached project.
Fundraising and Bylaws
In the last topic of our walkthrough, we handle the more advanced features present in Aragon, namely  fundraising on the blockchain and bylaws, which offer another level of fine-tuning for governance of your  company. Raising a round of funding on the Aragon blockchain is very different from traditional fundraising.  The core idea is simple: Once your DAO is operational, you can issue shares and then you can offer a class of  those shares to an investor in return for Ether. These shares can either be offered to an individual investor, or  more broadly to the any participant in the network. A round has a specific closing window and starts when  it has been approved by the company after voting. The second feature we discuss here is the bylaws, which  are the computational equivalent of a configuration file that allows variables to be reassigned and updated  as necessary. Bylaws provide a very granular level of access to the governing architecture of your company,  and if changes are approved, the new rules are implemented immediately. All the default settings that we  have referenced in previous topics arise from a template of bylaws adopted by Aragon to set up a company.  Although new bylaws cannot be added to Aragon yet, the existing rules can be changed to create different  levels of user permissions for members of the company. Let’s look at fundraising in Aragon in Figure 5-16.
63
Chapter 5 ■ Decentralized Organizations

Figure 5-16. Fundraising from a specific investor in Aragon
In the Aragon Core, there’s a Fundraising tab, where you can click New Raise to open the corresponding  dialog box. Currently there are two types of options for fundraising implemented in Aragon. The first one  involves raising a round from a specific investor in return for a stake in your company. The second option is  a crowdsale, where any participant of the network can buy stock in your company. In this case, we choose  the first option and start an individual raise. The series needs a title and the class of shares being offered in  return for the funds raised. Normally, an investor would want voting rights, so we picked CVS. After that,  you have to enter the investor’s address manually and then specify how many shares you want to offer. Once  the Aragon network has a true market, the shares can be priced in Ether and have tangible value on the  blockchain. The outcome of a project associated with the Aragon-powered DAO will determine the value of  the shares in market. The fundraiser has a time-window, at the end of which the round will close. This has  the potential to evolve into the all-or-nothing model that Kickstarter uses. Finally, the fundraiser needs to be  approved by a majority before it can become active and come online to the network.
64
Chapter 5 ■ Decentralized Organizations
Let’s look at the bylaws next. Figure 5-17 shows a list of currently implemented bylaws that every entity  participating in your company has agreed to honor. Eventually, executive-implemented rules will be allowed  in Aragon to offer even more customization over governance.
Figure 5-17. Bylaws for the company
The Bylaws tab lists all the available laws implemented for the company. We take a look here at the  first law, which dictates how voting can be initiated. In Aragon, every major action requires a vote from  the participants, so changing who can initiate a vote also implies that more actions can be performed that  require a vote. The action requirements in the Begin Voting dialog box provide a few options, such as being  a shareholder, having a role assigned in the company, or limiting voting to specific addresses (users). By  default, voting requires a shareholder, but that can be changed here as needed. As with every other major  action, a change in bylaws requires majority approval to be implemented company-wide.
Let’s look at another example, this time granting the power to assign roles to new users and how  identities can be integrated automatically using an oracle. Figure 5-18 provides a depiction of this example.
65
Chapter 5 ■ Decentralized Organizations

Figure 5-18. Changing the status of a member in your company
This process is similar to the previous step, but instead, we will edit the second bylaw, Set entity status,  here. In the Set Entity Status dialog box, select the last option: An oracle will be called for confirmation. This  changes the parameters, as now you just need to provide the address of the oracle on the network. How  does identity management function using an oracle? If your company requires some level of identification,  Aragon can be integrated with Keybase and an oracle can confirm the status of identification from Keybase.  In this way, new roles can be assigned without the need for a vote and only promotions or entity status  updates would require network-wide voting.
Summary
In this chapter, we discussed the concept of decentralized organizations. We started with a presentation  of Aragon in the context of decentralized organizations built on the blockchain. We talked about the  definition of a DAO and the organs that Aragon implements. We had an in-depth discussion on the identity  management features enabled by Aragon and Keybase. Finally, the heart of this chapter was the walkthrough  of how to set up, manage, and operate a DAO, including all its basic functions. This chapter has provided the  foundation for creating your own DAO.
